-- vim: syntax=lua
-- bgfx interface

typedef "bool"
typedef "char"
typedef "float"
typedef "int8_t"
typedef "int32_t"
typedef "int64_t"
typedef "uint8_t"
typedef "uint16_t"
typedef "uint32_t"
typedef "uint64_t"
typedef "uintptr_t"
typedef "va_list"
typedef "void"

typedef "Encoder"
typedef "InternalData"
typedef "ViewId"
typedef "CallbackI" { cname = "callback_interface" }
typedef "bx::AllocatorI" { cname = "allocator_interface" }

--- Memory release callback.
---
--- param[in] _ptr Pointer to allocated data.
--- param[in] _userData User defined data if needed.
funcptr.ReleaseFn
	"void"
	.ptr        "void*"
	.userData   "void*"

--- Fatal error enum.
enum.Fatal { underscore, comment = "" }
	.DebugCheck
	.InvalidShader
	.UnableToInitialize
	.UnableToCreateTexture
	.DeviceLost
	()	-- end of enum

--- Renderer backend type enum.
enum.RendererType { comment = "Renderer types:" }
	.Noop       [[No rendering.]]
	.Direct3D9  [[Direct3D 9.0]]
	.Direct3D11 [[Direct3D 11.0]]
	.Direct3D12 [[Direct3D 12.0]]
	.Gnm        [[GNM]]
	.Metal      [[Metal]]
	.OpenGLES   [[OpenGL ES 2.0+]]
	.OpenGL     [[OpenGL 2.1+]]
	.Vulkan     [[Vulkan]]

--- Access mode enum.
enum.Access { comment = "Access:" }
	.Read      [[Read]]
	.Write     [[Write]]
	.ReadWrite [[Read and write]]


--- Vertex attribute enum.
enum.Attrib { comment = "Corresponds to vertex shader attribute." }
	.Position  [[a_position]]
	.Normal    [[a_normal]]
	.Tangent   [[a_tangent]]
	.Bitangent [[a_bitangent]]
	.Color0    [[a_color0]]
	.Color1    [[a_color1]]
	.Color2    [[a_color2]]
	.Color3    [[a_color3]]
	.Indices   [[a_indices]]
	.Weight    [[a_weight]]
	.TexCoord0 [[a_texcoord0]]
	.TexCoord1 [[a_texcoord1]]
	.TexCoord2 [[a_texcoord2]]
	.TexCoord3 [[a_texcoord3]]
	.TexCoord4 [[a_texcoord4]]
	.TexCoord5 [[a_texcoord5]]
	.TexCoord6 [[a_texcoord6]]
	.TexCoord7 [[a_texcoord7]]

--- Vertex attribute type enum.
enum.AttribType { comment = "Attribute types:" }
	.Uint8  [[Uint8]]
	.Uint10 [[Uint10, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_UINT10`.]]
	.Int16  [[Int16]]
	.Half   [[Half, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_HALF`.]]
	.Float  [[Float]]

--- Texture format enum.
---
--- Notation:
---
---       RGBA16S
---       ^   ^ ^
---       |   | +-- [ ]Unorm
---       |   |     [F]loat
---       |   |     [S]norm
---       |   |     [I]nt
---       |   |     [U]int
---       |   +---- Number of bits per component
---       +-------- Components
---
--- @attention Availability depends on Caps (see: formats).
enum.TextureFormat { comment = "Texture formats:" }
	.BC1          [[DXT1]]
	.BC2          [[DXT3]]
	.BC3          [[DXT5]]
	.BC4          [[LATC1/ATI1]]
	.BC5          [[LATC2/ATI2]]
	.BC6H         [[BC6H]]
	.BC7          [[BC7]]
	.ETC1         [[ETC1 RGB8]]
	.ETC2         [[ETC2 RGB8]]
	.ETC2A        [[ETC2 RGBA8]]
	.ETC2A1       [[ETC2 RGB8A1]]
	.PTC12        [[PVRTC1 RGB 2BPP]]
	.PTC14        [[PVRTC1 RGB 4BPP]]
	.PTC12A       [[PVRTC1 RGBA 2BPP]]
	.PTC14A       [[PVRTC1 RGBA 4BPP]]
	.PTC22        [[PVRTC2 RGBA 2BPP]]
	.PTC24        [[PVRTC2 RGBA 4BPP]]
	.ATC          [[ATC RGB 4BPP]]
	.ATCE         [[ATCE RGBA 8 BPP explicit alpha]]
	.ATCI         [[ATCI RGBA 8 BPP interpolated alpha]]
	-- todo: ASTC4X4 would be better
	.ASTC4x4      { cname = "ASTC4x4" } [[ASTC 4x4 8.0 BPP]]
	.ASTC5x5      { cname = "ASTC5x5" } [[ASTC 5x5 5.12 BPP]]
	.ASTC6x6      { cname = "ASTC6x6" } [[ASTC 6x6 3.56 BPP]]
	.ASTC8x5      { cname = "ASTC8x5" } [[ASTC 8x5 3.20 BPP]]
	.ASTC8x6      { cname = "ASTC8x6" } [[ASTC 8x6 2.67 BPP]]
	.ASTC10x5     { cname = "ASTC10x5" } [[ASTC 10x5 2.56 BPP]]
	.Unknown      [[Compressed formats above.]]
	.R1
	.A8
	.R8
	.R8I
	.R8U
	.R8S
	.R16
	.R16I
	.R16U
	.R16F
	.R16S
	.R32I
	.R32U
	.R32F
	.RG8
	.RG8I
	.RG8U
	.RG8S
	.RG16
	.RG16I
	.RG16U
	.RG16F
	.RG16S
	.RG32I
	.RG32U
	.RG32F
	.RGB8
	.RGB8I
	.RGB8U
	.RGB8S
	.RGB9E5F
	.BGRA8
	.RGBA8
	.RGBA8I
	.RGBA8U
	.RGBA8S
	.RGBA16
	.RGBA16I
	.RGBA16U
	.RGBA16F
	.RGBA16S
	.RGBA32I
	.RGBA32U
	.RGBA32F
	.R5G6B5
	.RGBA4
	.RGB5A1
	.RGB10A2
	.RG11B10F
	.UnknownDepth [[Depth formats below.]]
	.D16
	.D24
	.D24S8
	.D32
	.D16F
	.D24F
	.D32F
	.D0S8
	()

--- Uniform type enum.
enum.UniformType          { comment = "Uniform types:" }
	.Sampler [[Sampler.]]
	.End     [[Reserved, do not use.]]
	.Vec4    [[4 floats vector.]]
	.Mat3    [[3x3 matrix.]]
	.Mat4    [[4x4 matrix.]]

--- Backbuffer ratio enum.
enum.BackbufferRatio      { comment = "Backbuffer ratios:" }
	.Equal     [[Equal to backbuffer.]]
	.Half      [[One half size of backbuffer.]]
	.Quarter   [[One quarter size of backbuffer.]]
	.Eighth    [[One eighth size of backbuffer.]]
	.Sixteenth [[One sixteenth size of backbuffer.]]
	.Double    [[Double size of backbuffer.]]

--- Occlusion query result.
enum.OcclusionQueryResult { comment = "Occlusion query results:" }
	.Invisible [[Query failed test.]]
	.Visible   [[Query passed test.]]
	.NoResult  [[Query result is not available yet.]]

--- Primitive topology.
enum.Topology { underscore, comment = "Primitive topology:" }
	.TriList   [[Triangle list.]]
	.TriStrip  [[Triangle strip.]]
	.LineList  [[Line list.]]
	.LineStrip [[Line strip.]]
	.PointList [[Point list.]]

--- Topology conversion function.
enum.TopologyConvert { underscore , comment = "Topology conversion functions:" }
	.TriListFlipWinding  [[Flip winding order of triangle list.]]
	.TriStripFlipWinding [[Flip winding order of trinagle strip.]]
	.TriListToLineList   [[Convert triangle list to line list.]]
	.TriStripToTriList   [[Convert triangle strip to triangle list.]]
	.LineStripToLineList [[Convert line strip to line list.]]

--- Topology sort order.
enum.TopologySort { underscore, comment = "Topology sort order:" , }
	.DirectionFrontToBackMin
	.DirectionFrontToBackAvg
	.DirectionFrontToBackMax
	.DirectionBackToFrontMin
	.DirectionBackToFrontAvg
	.DirectionBackToFrontMax
	.DistanceFrontToBackMin
	.DistanceFrontToBackAvg
	.DistanceFrontToBackMax
	.DistanceBackToFrontMin
	.DistanceBackToFrontAvg
	.DistanceBackToFrontMax
	()

--- View mode sets draw call sort order.
enum.ViewMode { underscore, comment = "View modes:" }
	.Default         [[Default sort order.]]
	.Sequential      [[Sort in the same order in which submit calls were called.]]
	.DepthAscending   [[Sort draw call depth in ascending order.]]
	.DepthDescending  [[Sort draw call depth in descending order.]]

--- Render frame enum.
enum.RenderFrame { underscore, comment = "" }
	.NoContext
	.Render
	.Timeout
	.Exiting
	()

--- Platform data.
struct.PlatformData { ctor }
	.ndt          "void*" [[Native display type.]]
	.nwh          "void*" [[Native window handle.]]
	.context      "void*" [[GL context, or D3D device.]]
	.backBuffer   "void*" [[GL backbuffer, or D3D render target view.]]
	.backBufferDS "void*" [[Backbuffer depth/stencil.]]

--- Backbuffer resolution and reset parameters.
struct.Resolution { ctor }
	.format          "TextureFormat::Enum" [[Backbuffer format.]]
	.width           "uint32_t"            [[Backbuffer width.]]
	.height          "uint32_t"            [[Backbuffer height.]]
	.reset           "uint32_t"            [[Reset parameters.]]
	.numBackBuffers  "uint8_t"             [[Number of back buffers.]]
	.maxFrameLatency "uint8_t"             [[Maximum frame latency.]]

struct.Limits { namespace = "Init" }
	.maxEncoders    "uint16_t"             [[Maximum number of encoder threads.]]
	.transientVbSize "uint32_t"            [[Maximum transient vertex buffer size.]]
	.transientIbSize "uint32_t"            [[Maximum transient index buffer size.]]

--- Initialization parameters used by `bgfx::init`.
struct.Init { ctor }
	.type            "RendererType::Enum"  [[Select rendering backend. When set to RendererType::Count]]
	                                       [[a default rendering backend will be selected appropriate to the platform.]]
	                                       [[See: `bgfx::RendererType`]]

	.vendorId       "uint16_t"             [[Vendor PCI id. If set to `BGFX_PCI_ID_NONE` it will select the first]]
	                                       [[device.                                                             ]]
	                                       [[  - `BGFX_PCI_ID_NONE` - Autoselect adapter.                        ]]
	                                       [[  - `BGFX_PCI_ID_SOFTWARE_RASTERIZER` - Software rasterizer.        ]]
	                                       [[  - `BGFX_PCI_ID_AMD` - AMD adapter.                                ]]
	                                       [[  - `BGFX_PCI_ID_INTEL` - Intel adapter.                            ]]
	                                       [[  - `BGFX_PCI_ID_NVIDIA` - nVidia adapter.                          ]]

	.deviceId       "uint16_t"             [[Device id. If set to 0 it will select first device, or device with ]]
	                                       [[matching id. ]]

	.debug          "bool"                 [[Enable device for debuging.]]
	.profile        "bool"                 [[Enable device for profiling.]]
	.platformData   "PlatformData"         [[Platform data.]]
	.resolution     "Resolution"           [[Backbuffer resolution and reset parameters. See: `bgfx::Resolution`.]]
	.limits         "Limits"
	.callback       "CallbackI*"           [[Provide application specific callback interface.]]
	                                       [[See: `bgfx::CallbackI`]]

	.allocator      "bx::AllocatorI*"      [[Custom allocator. When a custom allocator is not    ]]
	                                       [[specified, bgfx uses the CRT allocator. Bgfx assumes]]
	                                       [[custom allocator is thread safe.                    ]]

--- Memory must be obtained by calling `bgfx::alloc`, `bgfx::copy`, or `bgfx::makeRef`.
---
--- @attention It is illegal to create this structure on stack and pass it to any bgfx API.
struct.Memory
	.data "uint8_t*" [[Pointer to data.]]
	.size "uint32_t" [[Data size.]]

--- GPU info.
struct.GPU  { namespace = "Caps" }
	.vendorId    "uint16_t"                [[Vendor PCI id. See `BGFX_PCI_ID_*`.]]
	.deviceId    "uint16_t"                [[Device id.]]

struct.Limits  { namespace = "Caps" }
	.maxDrawCalls            "uint32_t"    [[Maximum number of draw calls.                       ]]
	.maxBlits                "uint32_t"    [[Maximum number of blit calls.			     ]]
	.maxTextureSize          "uint32_t"    [[Maximum texture size.				     ]]
	.maxTextureLayers        "uint32_t"    [[Maximum texture layers.			     ]]
	.maxViews                "uint32_t"    [[Maximum number of views.			     ]]
	.maxFrameBuffers         "uint32_t"    [[Maximum number of frame buffer handles.	     ]]
	.maxFBAttachments        "uint32_t"    [[Maximum number of frame buffer attachments.	     ]]
	.maxPrograms             "uint32_t"    [[Maximum number of program handles.		     ]]
	.maxShaders              "uint32_t"    [[Maximum number of shader handles.		     ]]
	.maxTextures             "uint32_t"    [[Maximum number of texture handles.		     ]]
	.maxTextureSamplers      "uint32_t"    [[Maximum number of texture samplers.		     ]]
	.maxComputeBindings      "uint32_t"    [[Maximum number of compute bindings.		     ]]
	.maxVertexDecls          "uint32_t"    [[Maximum number of vertex format declarations.	     ]]
	.maxVertexStreams        "uint32_t"    [[Maximum number of vertex streams.		     ]]
	.maxIndexBuffers         "uint32_t"    [[Maximum number of index buffer handles.	     ]]
	.maxVertexBuffers        "uint32_t"    [[Maximum number of vertex buffer handles.	     ]]
	.maxDynamicIndexBuffers  "uint32_t"    [[Maximum number of dynamic index buffer handles.     ]]
	.maxDynamicVertexBuffers "uint32_t"    [[Maximum number of dynamic vertex buffer handles.    ]]
	.maxUniforms             "uint32_t"    [[Maximum number of uniform handles.		     ]]
	.maxOcclusionQueries     "uint32_t"    [[Maximum number of occlusion query handles.	     ]]
	.maxEncoders             "uint32_t"    [[Maximum number of encoder threads.		     ]]
	.transientVbSize         "uint32_t"    [[Maximum transient vertex buffer size.		     ]]
	.transientIbSize         "uint32_t"    [[Maximum transient index buffer size.		     ]]

--- Renderer capabilities.
struct.Caps
	.rendererType "RendererType::Enum"     [[Renderer backend type. See: `bgfx::RendererType`]]

	.supported    "uint64_t"               [[Supported functionality.                                                                      ]]
	                                       [[                                                                                              ]]
	                                       [[@attention See BGFX_CAPS_* flags at https://bkaradzic.github.io/bgfx/bgfx.html#available-caps ]]
	.vendorId     "uint16_t"               [[Selected GPU vendor PCI id.]]
	.deviceId     "uint16_t"               [[Selected GPU device id.]]
	.homogeneousDepth "bool"               [[True when NDC depth is in [-1, 1] range, otherwise its [0, 1].]]
	.originBottomLeft "bool"               [[True when NDC origin is at bottom left.]]
	.numGPUs      "uint8_t"                [[Number of enumerated GPUs.]]
	.gpu          "GPU[4]"                 [[Enumerated GPUs.]]
	.limits       "Limits"
	.formats      "uint16_t[TextureFormat::Count]"
		[[Supported texture format capabilities flags:                                               ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_NONE` - Texture format is not supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D_SRGB` - Texture as sRGB format is supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D_SRGB` - Texture as sRGB format is supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_SRGB` - Texture as sRGB format is supported.	     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_VERTEX` - Texture format can be used from vertex shader.     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_IMAGE` - Texture format can be used as image from compute    ]]
		[[    shader.										     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER` - Texture format can be used as frame	     ]]
		[[    buffer.										     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER_MSAA` - Texture format can be used as MSAA	     ]]
		[[    frame buffer.									     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_MSAA` - Texture can be sampled as MSAA.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_MIP_AUTOGEN` - Texture format supports auto-generated	     ]]
		[[    mips.										     ]]

--- Transient index buffer.
struct.TransientIndexBuffer
	.data       "int8_t*"           [[Pointer to data.]]
	.size       "uint32_t"          [[Data size.]]
	.startIndex "uint32_t"          [[First index.]]
	.handle     "IndexBufferHandle" [[Index buffer handle.]]

--- Transient vertex buffer.
struct.TransientVertexBuffer
	.data        "int8_t*"            [[Pointer to data.]]
	.size        "uint32_t"           [[Data size.]]
	.startVertex "uint32_t"           [[First vertex.]]
	.stride      "uint16_t"           [[Vertex stride.]]
	.handle      "VertexBufferHandle" [[Vertex buffer handle.]]
	.decl        "VertexDeclHandle"   [[Vertex declaration handle.]]

--- Instance data buffer info.
struct.InstanceDataBuffer
	.data   "int8_t*"            [[Pointer to data.]]
	.size   "uint32_t"           [[Data size.]]
	.offset "uint32_t"           [[Offset in vertex buffer.]]
	.num    "uint32_t"           [[Number of instances.]]
	.stride "uint16_t"           [[Vertex buffer stride.]]
	.handle "VertexBufferHandle" [[Vertex buffer object handle.]]

--- Texture info.
struct.TextureInfo
	.format       "TextureFormat::Enum" [[Texture format.]]
	.storageSize  "uint32_t"            [[Total amount of bytes required to store texture.]]
	.width        "uint16_t"            [[Texture width.]]
	.height       "uint16_t"            [[Texture height.]]
	.depth        "uint16_t"            [[Texture depth.]]
	.numLayers    "uint16_t"            [[Number of layers in texture array.]]
	.numMips      "uint8_t"             [[Number of MIP maps.]]
	.bitsPerPixel "uint8_t"             [[Format bits per pixel.]]
	.cubeMap      "bool"                [[Texture is cubemap.]]

--- Uniform info.
struct.UniformInfo
	.name "char[256]"         [[Uniform name.]]
	.type "UniformType::Enum" [[Uniform type.]]
	.num  "uint16_t"          [[Number of elements in array.]]

--- Frame buffer texture attachment info.
struct.Attachment
	.access  "Access::Enum"  [[Attachement access. See `Access::Enum`.]]
	.handle  "TextureHandle" [[Render target texture handle.]]
	.mip     "uint16_t"      [[Mip level.]]
	.layer   "uint16_t"      [[Cubemap side or depth layer/slice.]]
	.resolve "uint8_t"       [[Resolve flags. See: `BGFX_RESOLVE_*`]]

--- Transform data.
struct.Transform
	.data "float*"  [[Pointer to first 4x4 matrix.]]
	.num "uint16_t" [[Number of matrices.]]

--- View stats.
struct.ViewStats
	.name           "char[256]" [[View name.]]
	.view           "ViewId"    [[View id.]]
	.cpuTimeElapsed "int64_t"   [[CPU (submit) time elapsed.]]
	.gpuTimeElapsed "int64_t"   [[GPU time elapsed.]]

--- Encoder stats.
struct.EncoderStats
	.cpuTimeBegin "int64_t" [[Encoder thread CPU submit begin time.]]
	.cpuTimeEnd   "int64_t" [[Encoder thread CPU submit end time.]]

--- Renderer statistics data.
struct.Stats
	.cpuTimeFrame            "int64_t"       [[CPU time between two `bgfx::frame` calls.]]
	.cpuTimeBegin            "int64_t"       [[Render thread CPU submit begin time.]]
	.cpuTimeEnd              "int64_t"       [[Render thread CPU submit end time.]]
	.cpuTimerFreq            "int64_t"       [[CPU timer frequency. Timestamps-per-second]]
	.gpuTimeBegin            "int64_t"       [[GPU frame begin time.]]
	.gpuTimeEnd              "int64_t"       [[GPU frame end time.]]
	.gpuTimerFreq            "int64_t"       [[GPU timer frequency.]]
	.waitRender              "int64_t"       [[Time spent waiting for render backend thread to finish issuing draw commands to underlying graphics API.]]
	.waitSubmit              "int64_t"       [[Time spent waiting for submit thread to advance to next frame.]]
	.numDraw                 "uint32_t"      [[Number of draw calls submitted.]]
	.numCompute              "uint32_t"      [[Number of compute calls submitted.]]
	.numBlit                 "uint32_t"      [[Number of blit calls submitted.]]
	.maxGpuLatency           "uint32_t"      [[GPU driver latency.]]
	.numDynamicIndexBuffers  "uint16_t"      [[Number of used dynamic index buffers.]]
	.numDynamicVertexBuffers "uint16_t"      [[Number of used dynamic vertex buffers.]]
	.numFrameBuffers         "uint16_t"      [[Number of used frame buffers.]]
	.numIndexBuffers         "uint16_t"      [[Number of used index buffers.]]
	.numOcclusionQueries     "uint16_t"      [[Number of used occlusion queries.]]
	.numPrograms             "uint16_t"      [[Number of used programs.]]
	.numShaders              "uint16_t"      [[Number of used shaders.]]
	.numTextures             "uint16_t"      [[Number of used textures.]]
	.numUniforms             "uint16_t"      [[Number of used uniforms.]]
	.numVertexBuffers        "uint16_t"      [[Number of used vertex buffers.]]
	.numVertexDecls          "uint16_t"      [[Number of used vertex declarations.]]
	.textureMemoryUsed       "int64_t"       [[Estimate of texture memory used.]]
	.rtMemoryUsed            "int64_t"       [[Estimate of render target memory used.]]
	.transientVbUsed         "int32_t"       [[Amount of transient vertex buffer used.]]
	.transientIbUsed         "int32_t"       [[Amount of transient index buffer used.]]
	.numPrims                "uint32_t[Topology::Count]"      [[Number of primitives rendered.]]
	.gpuMemoryMax            "int64_t"       [[Maximum available GPU memory for application.]]
	.gpuMemoryUsed           "int64_t"       [[Amount of GPU memory used by the application.]]
	.width                   "uint16_t"      [[Backbuffer width in pixels.]]
	.height                  "uint16_t"      [[Backbuffer height in pixels.]]
	.textWidth               "uint16_t"      [[Debug text width in characters.]]
	.textHeight              "uint16_t"      [[Debug text height in characters.]]
	.numViews                "uint16_t"      [[Number of view stats.]]
	.viewStats               "ViewStats*"    [[Array of View stats.]]
	.numEncoders             "uint8_t"       [[Number of encoders used during frame.]]
	.encoderStats            "EncoderStats*" [[Array of encoder stats.]]

--- Vertex declaration.
struct.VertexDecl { ctor }
	.hash                    "uint32_t"
	.stride                  "uint16_t"
	.offset                  "uint16_t[Attrib::Count]"
	.attributes              "uint16_t[Attrib::Count]"

handle "DynamicIndexBufferHandle"
handle "DynamicVertexBufferHandle"
handle "FrameBufferHandle"
handle "IndexBufferHandle"
handle "IndirectBufferHandle"
handle "OcclusionQueryHandle"
handle "ProgramHandle"
handle "ShaderHandle"
handle "TextureHandle"
handle "UniformHandle"
handle "VertexBufferHandle"
handle "VertexDeclHandle"

func.VertexDecl.begin
	"void"
	.rendererType    "RendererType::Enum"

func.VertexDecl.add
	"void"
	.attrib          "Attrib::Enum"
	.num             "uint8_t"
	.type            "AttribType::Enum"
	.normalized      "bool"
	.asInt           "bool"

func.VertexDecl.decode { const }
	"void"
	.attrib     "Attrib::Enum"
	.num        "uint8_t &"          { out }
	.type       "AttribType::Enum &" { out }
	.normalized "bool &"             { out }
	.asInt      "bool &"             { out }

func.VertexDecl.has { const }
	"bool"
	.attrib "Attrib::Enum"

func.VertexDecl.skip
	"void"
	.num "uint8_t"

-- Notice: `end` is a keyword in lua
func.VertexDecl["end"]
	"void"

func.vertexPack
	"void"
	.input           "const float[4]"
	.inputNormalized "bool"
	.attr            "Attrib::Enum"
	.decl            "const VertexDecl &"
	.data            "void*"
	.index           "uint32_t"

func.vertexUnpack
	"void"
	.output "float[4]" { out }
	.attr   "Attrib::Enum"
	.decl   "const VertexDecl &"
	.data   "const void*"
	.index  "uint32_t"

func.vertexConvert
	"void"
	.dstDecl "const VertexDecl &"
	.dstData "void*"
	.srcDecl "const VertexDecl &"
	.srcData "const void*"
	.num     "uint32_t"

func.weldVertices
	"uint16_t"
	.output  "uint16_t*"
	.decl    "const VertexDecl &"
	.data    "const void*"
	.num     "uint16_t"
	.epsilon "float"

func.topologyConvert
	"uint32_t"
	.conversion "TopologyConvert::Enum"
	.dst        "void*" { out }
	.dstSize    "uint32_t"
	.indices    "const void*"
	.numIndices "uint32_t"
	.index32    "bool"

func.topologySortTriList
	"void"
	.sort       "TopologySort::Enum"
	.dst        "void*" { out }
	.dstSize    "uint32_t"
	.dir        "const float[3]"
	.pos        "const float[3]"
	.vertices   "const void*"
	.stride     "uint32_t"
	.indices    "const void*"
	.numIndices "uint32_t"
	.index32    "bool"

func.getSupportedRenderers
	"uint8_t"
	.max  "uint8_t"
	.enum "RendererType::Enum*" { out }

func.getRendererName
	"const char*"
	.type "RendererType::Enum"

local init_ctor = [[
	BX_PLACEMENT_NEW(_init, bgfx::Init);
]]
func.initCtor { cfunc = init_ctor }
	"void"
	.init "Init*"

local init = [[
	bgfx_init_t init =*_init;

	if (init.callback != NULL)
	{
		static bgfx::CallbackC99 s_callback;
		s_callback.m_interface = init.callback;
		init.callback = reinterpret_cast<bgfx_callback_interface_t*>(&s_callback);
	}

	if (init.allocator != NULL)
	{
		static bgfx::AllocatorC99 s_allocator;
		s_allocator.m_interface = init.allocator;
		init.allocator = reinterpret_cast<bgfx_allocator_interface_t*>(&s_allocator);
	}

	union { const bgfx_init_t* c; const bgfx::Init* cpp; } in;
	in.c = &init;

	return bgfx::init(*in.cpp);
]]
func.init { cfunc = init }
	"bool"
	.init "const Init &"

func.shutdown
	"void"

func.reset
	"void"
	.width  "uint32_t"
	.height "uint32_t"
	.flags  "uint32_t"
	.format "TextureFormat::Enum"

func.frame
	"uint32_t"
	.capture "bool"  { default = false }

func.getRendererType
	"RendererType::Enum"

func.getCaps
	"const Caps*"

func.getStats
	"const Stats*"

func.alloc
	"const Memory*"
	.size "uint32_t"

func.copy
	"const Memory*"
	.data "const void*"
	.size "uint32_t"

func.makeRef
	"const Memory*"
	.data "const void*"
	.size "uint32_t"

func.makeRef { cname = "make_ref_release" }
	"const Memory*"
	.data      "const void*"
	.size      "uint32_t"
	.releaseFn "ReleaseFn" { default = NULL }
	.userData  "void*" { default = NULL }

func.setDebug
	"void"
	.debug "uint32_t"

func.dbgTextClear
	"void"
	.attr  "uint8_t"
	.small "bool"

func.dbgTextPrintf { vararg = "dbgTextPrintfVargs" }
	"void"
	.x      "uint16_t"
	.y      "uint16_t"
	.attr   "uint8_t"
	.format "const char*"

func.dbgTextPrintfVargs { cname = "dbg_text_vprintf" }
	"void"
	.x       "uint16_t"
	.y       "uint16_t"
	.attr    "uint8_t"
	.format  "const char*"
	.argList "va_list"

func.dbgTextImage
	"void"
	.x       "uint16_t"
	.y       "uint16_t"
	.width   "uint16_t"
	.height  "uint16_t"
	.data    "const void*"
	.pitch   "uint16_t"

func.createIndexBuffer
	"IndexBufferHandle"
	.mem   "const Memory*"
	.flags "uint16_t"

func.setName { cname = "set_index_buffer_name" }
	"void"
	.handle "IndexBufferHandle"
	.name   "const char*"
	.len    "int32_t"

func.destroy { cname = "destroy_index_buffer" }
	"void"
	.handle "IndexBufferHandle"

func.createVertexBuffer
	"VertexBufferHandle"
	.mem   "const Memory*"
	.decl  "const VertexDecl &"
	.flags "uint16_t"

func.setName { cname = "set_vertex_buffer_name" }
	"void"
	.handle "VertexBufferHandle"
	.name   "const char*"
	.len    "int32_t"

func.destroy { cname = "destroy_vertex_buffer" }
	"void"
	.handle "VertexBufferHandle"

func.createDynamicIndexBuffer
	"DynamicIndexBufferHandle"
	.num   "uint32_t"
	.flags "uint16_t"

func.createDynamicIndexBuffer { cname = "create_dynamic_index_buffer_mem" }
	"DynamicIndexBufferHandle"
	.mem   "const Memory*"
	.flags "uint16_t"

func.update { cname = "update_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle"
	.startIndex "uint32_t"
	.mem        "const Memory*"

func.destroy { cname = "destroy_dynamic_index_buffer" }
	"void"
	.handle "DynamicIndexBufferHandle"

func.createDynamicVertexBuffer
	"DynamicVertexBufferHandle"
	.num   "uint32_t"
	.decl  "const VertexDecl &"
	.flags "uint16_t"

func.createDynamicVertexBuffer { cname = "create_dynamic_vertex_buffer_mem" }
	"DynamicVertexBufferHandle"
	.mem   "const Memory*"
	.decl  "const VertexDecl &"
	.flags "uint16_t"

func.update { cname = "update_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.mem         "const Memory*"

func.destroy { cname = "destroy_dynamic_vertex_buffer" }
	"void"
	.handle "DynamicVertexBufferHandle"

func.getAvailTransientIndexBuffer
	"uint32_t"
	.num "uint32_t"

func.getAvailTransientVertexBuffer
	"uint32_t"
	.num "uint32_t"
	.decl  "const VertexDecl &"

func.getAvailInstanceDataBuffer
	"uint32_t"
	.num    "uint32_t"
	.stride "uint16_t"

func.allocTransientIndexBuffer
	"void"
	.tib "TransientIndexBuffer*" { out }
	.num "uint32_t"

func.allocTransientVertexBuffer
	"void"
	.tvb  "TransientVertexBuffer*" { out }
	.num  "uint32_t"
	.decl "const VertexDecl &"

func.allocTransientBuffers
	"bool"
	.tvb         "TransientVertexBuffer*" { out }
	.decl        "const VertexDecl &"
	.numVertices "uint32_t"
	.tib         "TransientIndexBuffer*" { out }
	.numIndices  "uint32_t"

func.allocInstanceDataBuffer
	"void"
	.idb    "InstanceDataBuffer*" { out }
	.num    "uint32_t"
	.stride "uint16_t"

func.createIndirectBuffer
	"IndirectBufferHandle"
	.num "uint32_t"

func.destroy { cname = "destroy_indirect_buffer" }
	"void"
	.handle "IndirectBufferHandle"

func.createShader
	"ShaderHandle"
	.mem "const Memory*"

func.getShaderUniforms
	"uint16_t"
	.handle   "ShaderHandle"
	.uniforms "UniformHandle*" { out }
	.max      "uint16_t"

func.setName { cname = "set_shader_name" }
	"void"
	.handle "ShaderHandle"
	.name   "const char*"
	.len    "int32_t"

func.destroy { cname = "destroy_shader" }
	"void"
	.handle "ShaderHandle"

func.createProgram
	"ProgramHandle"
	.vsh "ShaderHandle"
	.fsh "ShaderHandle"
	.destroyShaders "bool"

func.createProgram { cname = "create_compute_program" }
	"ProgramHandle"
	.csh "ShaderHandle"
	.destroyShaders "bool"

func.destroy { cname = "destroy_program" }
	"void"
	.handle "ProgramHandle"

func.isTextureValid
	"bool"
	.depth     "uint16_t"
	.cubeMap   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"

func.calcTextureSize
	"void"
	.info      "TextureInfo &" { out }
	.width     "uint16_t"
	.height    "uint16_t"
	.depth     "uint16_t"
	.cubeMap   "bool"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"

func.createTexture
	"TextureHandle"
	.mem   "const Memory*"
	.flags "uint64_t"
	.skip  "uint8_t"
	.info  "TextureInfo*" { out }

func.createTexture2D
	"TextureHandle"
	.width     "uint16_t"
	.height    "uint16_t"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.createTexture2D { cname = "create_texture_2d_scaled" }
	"TextureHandle"
	.ratio     "BackbufferRatio::Enum"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"

func.createTexture3D
	"TextureHandle"
	.width     "uint16_t"
	.height    "uint16_t"
	.depth     "uint16_t"
	.hasMips   "bool"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.createTextureCube
	"TextureHandle"
	.size      "uint16_t"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.updateTexture2D
	"void"
	.handle "TextureHandle"
	.layer  "uint16_t"
	.mip    "uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.mem    "const Memory*"
	.pitch  "uint16_t"

func.updateTexture3D
	"void"
	.handle "TextureHandle"
	.mip    "uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.z      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.depth  "uint16_t"
	.mem    "const Memory*"

func.updateTextureCube
	"void"
	.handle "TextureHandle"
	.layer  "uint16_t"
	.side   "uint8_t"
	.mip    "uint8_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.mem    "const Memory*"
	.pitch  "uint16_t"

func.readTexture
	"uint32_t"
	.handle "TextureHandle"
	.data   "void*"
	.mip    "uint8_t"

func.setName { cname = "set_texture_name" }
	"void"
	.handle "TextureHandle"
	.name   "const char*"
	.len    "int32_t"

func.getDirectAccessPtr
	"void*"
	.handle "TextureHandle"

func.destroy { cname = "destroy_texture" }
	"void"
	.handle "TextureHandle"

func.createFrameBuffer
	"FrameBufferHandle"
	.width        "uint16_t"
	.height       "uint16_t"
	.format       "TextureFormat::Enum"
	.textureFlags "uint64_t"

func.createFrameBuffer { cname = "create_frame_buffer_scaled" }
	"FrameBufferHandle"
	.ratio        "BackbufferRatio::Enum"
	.format       "TextureFormat::Enum"
	.textureFlags "uint64_t"

func.createFrameBuffer { cname = "create_frame_buffer_from_handles" }
	"FrameBufferHandle"
	.num            "uint8_t"
	.handles        "const TextureHandle*"
	.destroyTexture "bool"

func.createFrameBuffer { cname = "create_frame_buffer_from_attachment" }
	"FrameBufferHandle"
	.num            "uint8_t"
	.handles        "const Attachment*"
	.destroyTexture "bool"

func.createFrameBuffer { cname = "create_frame_buffer_from_nwh" }
	"FrameBufferHandle"
	.nwh         "void*"
	.width       "uint16_t"
	.height      "uint16_t"
	.format      "TextureFormat::Enum"
	.depthFormat "TextureFormat::Enum"

func.setName { cname = "set_frame_buffer_name" }
	"void"
	.handle "FrameBufferHandle"
	.name   "const char*"
	.len    "int32_t"

func.getTexture
	"TextureHandle"
	.handle     "FrameBufferHandle"
	.attachment "uint8_t"

func.destroy { cname = "destroy_frame_buffer" }
	"void"
	.handle "FrameBufferHandle"

func.createUniform
	"UniformHandle"
	.name "const char*"
	.type "UniformType::Enum"
	.num  "uint16_t"

func.getUniformInfo
	"void"
	.handle "UniformHandle"
	.info   "UniformInfo &" { out }

func.destroy { cname = "destroy_uniform" }
	"void"
	.handle "UniformHandle"

func.createOcclusionQuery
	"OcclusionQueryHandle"

func.getResult
	"OcclusionQueryResult::Enum"
	.handle "OcclusionQueryHandle"
	.result "int32_t*" { out }

func.destroy { cname = "destroy_occlusion_query" }
	"void"
	.handle "OcclusionQueryHandle"

func.setPaletteColor
	"void"
	.index "uint8_t"
	.rgba  "const float[4]"

func.setViewName
	"void"
	.id   "ViewId"
	.name "const char*"

func.setViewRect
	"void"
	.id     "ViewId"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.setViewRect { cname = "set_view_rect_ratio" }
	"void"
	.id    "ViewId"
	.x     "uint16_t"
	.y     "uint16_t"
	.ratio "BackbufferRatio::Enum"

func.setViewScissor
	"void"
	.id     "ViewId"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.setViewClear
	"void"
	.id      "ViewId"
	.flags   "uint16_t"
	.rgba    "uint32_t"
	.depth   "float"
	.stencil "uint8_t"

func.setViewClear { cname = "set_view_clear_mrt" }
	"void"
	.id      "ViewId"
	.flags   "uint16_t"
	.depth   "float"
	.stencil "uint8_t"
	.c0      "uint8_t"
	.c1      "uint8_t"
	.c2      "uint8_t"
	.c3      "uint8_t"
	.c4      "uint8_t"
	.c5      "uint8_t"
	.c6      "uint8_t"
	.c7      "uint8_t"

func.setViewMode
	"void"
	.id   "ViewId"
	.mode "ViewMode::Enum"

func.setViewFrameBuffer
	"void"
	.id     "ViewId"
	.handle "FrameBufferHandle"

func.setViewTransform
	"void"
	.id   "ViewId"
	.view "const void*"
	.proj "const void*"

func.setViewOrder
	"void"
	.id    "ViewId"
	.num   "uint16_t"
	.order "const ViewId*"

func.begin { cname = "encoder_begin" }
	"Encoder*"
	.forThread "bool"

func["end"] { cname = "encoder_end" }
	"void"
	.encoder "Encoder*"

func.Encoder.setMarker
	"void"
	.marker "const char*"

func.Encoder.setState
	"void"
	.state "uint64_t"
	.rgba  "uint32_t"

func.Encoder.setCondition
	"void"
	.handle  "OcclusionQueryHandle"
	.visible "bool"

func.Encoder.setStencil
	"void"
	.fstencil "uint32_t"
	.bstencil "uint32_t"

func.Encoder.setScissor
	"uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.Encoder.setScissor { cname = "set_scissor_cached" }
	"void"
	.cache "uint16_t"

func.Encoder.setTransform
	"uint32_t"
	.mtx "const void*"
	.num "uint16_t"

func.Encoder.setTransform { cname = "set_transform_cached" }
	"void"
	.cache "uint32_t"
	.num   "uint16_t"

func.Encoder.allocTransform
	"uint32_t"
	.transform "Transform*" { out }
	.num       "uint16_t"

func.Encoder.setUniform
	"void"
	.handle "UniformHandle"
	.value  "const void*"
	.num    "uint16_t"

func.Encoder.setIndexBuffer
	"void"
	.handle     "IndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setIndexBuffer { cname = "set_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setIndexBuffer { cname = "set_transient_index_buffer" }
	"void"
	.tib        "const TransientIndexBuffer*"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setVertexBuffer
	"void"
	.stream      "uint8_t"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexBuffer { cname = "set_dynamic_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexBuffer { cname = "set_transient_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.tvb         "const TransientVertexBuffer*"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexCount
	"void"
	.numVertices "uint32_t"

func.Encoder.setInstanceDataBuffer
	"void"
	.idb   "const InstanceDataBuffer*"
	.start "uint32_t"
	.num   "uint32_t"

func.Encoder.setInstanceDataBuffer { cname = "set_instance_data_from_vertex_buffer" }
	"void"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.Encoder.setInstanceDataBuffer { cname = "set_instance_data_from_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.Encoder.setInstanceCount
	"void"
	.numInstances "uint32_t"

func.Encoder.setTexture
	"void"
	.stage   "uint8_t"
	.sampler "UniformHandle"
	.handle  "TextureHandle"
	.flags   "uint32_t"

func.Encoder.touch
	"void"
	.id "ViewId"

func.Encoder.submit
	"void"
	.id            "ViewId"
	.program       "ProgramHandle"
	.depth         "uint32_t"
	.preserveState "bool"

func.Encoder.submit { cname = "submit_occlusion_query" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.occlusionQuery "OcclusionQueryHandle"
	.depth          "uint32_t"
	.preserveState  "bool"

func.Encoder.submit { cname = "submit_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"
	.depth          "uint32_t"
	.preserveState  "bool"

func.Encoder.setBuffer { cname = "set_compute_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "VertexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_dynamic_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicIndexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_dynamic_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicVertexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_indirect_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndirectBufferHandle"
	.access "Access::Enum"

func.Encoder.setImage
	"void"
	.stage  "uint8_t"
	.handle "TextureHandle"
	.mip    "uint8_t"
	.access "Access::Enum"
	.format "TextureFormat::Enum"  { default = "TextureFormat::Count" }

func.Encoder.dispatch
	"void"
	.id      "ViewId"
	.program "ProgramHandle"
	.numX    "uint32_t"
	.numY    "uint32_t"
	.numZ    "uint32_t"

func.Encoder.dispatch { cname = "dispatch_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"

func.Encoder.discard
	"void"

func.Encoder.blit
	"void"
	.id     "ViewId"
	.dst    "TextureHandle"
	.dstMip "uint8_t"
	.dstX   "uint16_t"
	.dstY   "uint16_t"
	.dstZ   "uint16_t"
	.src    "TextureHandle"
	.srcMip "uint8_t"
	.srcX   "uint16_t"
	.srcY   "uint16_t"
	.srcZ   "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.depth  "uint16_t"

func.requestScreenShot
	"void"
	.handle   "FrameBufferHandle"
	.filePath "const char*"

func.renderFrame
	"RenderFrame::Enum"
	.msecs "int32_t"

func.setPlatformData
	"void"
	.data "const PlatformData &"

func.getInternalData
	"const InternalData*"

func.overrideInternal { cname = "override_internal_texture_ptr" }
	"uintptr_t"
	.handle "TextureHandle"
	.ptr    "uintptr_t"

func.overrideInternal { cname = "override_internal_texture" }
	"uintptr_t"
	.handle  "TextureHandle"
	.width   "uint16_t"
	.height  "uint16_t"
	.numMips "uint8_t"
	.format  "TextureFormat::Enum"
	.flags   "uint32_t"



-- Legacy API:

func.setMarker
	"void"
	.marker "const char*"

func.setState
	"void"
	.state "uint64_t"
	.rgba  "uint32_t"

func.setCondition
	"void"
	.handle  "OcclusionQueryHandle"
	.visible "bool"

func.setStencil
	"void"
	.fstencil "uint32_t"
	.bstencil "uint32_t"

func.setScissor
	"uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.setScissor { cname = "set_scissor_cached" }
	"void"
	.cache "uint16_t"

func.setTransform
	"uint32_t"
	.mtx "const void*"
	.num "uint16_t"

func.setTransform { cname = "set_transform_cached" }
	"void"
	.cache "uint32_t"
	.num   "uint16_t"

func.allocTransform
	"uint32_t"
	.transform "Transform*" { out }
	.num       "uint16_t"

func.setUniform
	"void"
	.handle "UniformHandle"
	.value  "const void*"
	.num    "uint16_t"

func.setIndexBuffer
	"void"
	.handle     "IndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setIndexBuffer { cname = "set_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setIndexBuffer { cname = "set_transient_index_buffer" }
	"void"
	.tib        "const TransientIndexBuffer*"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setVertexBuffer
	"void"
	.stream      "uint8_t"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexBuffer { cname = "set_dynamic_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexBuffer { cname = "set_transient_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.tvb         "const TransientVertexBuffer*"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexCount
	"void"
	.numVertices "uint32_t"

func.setInstanceDataBuffer
	"void"
	.idb   "const InstanceDataBuffer*"
	.start "uint32_t"
	.num   "uint32_t"

func.setInstanceDataBuffer { cname = "set_instance_data_from_vertex_buffer" }
	"void"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.setInstanceDataBuffer { cname = "set_instance_data_from_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.setInstanceCount
	"void"
	.numInstances "uint32_t"

func.setTexture
	"void"
	.stage   "uint8_t"
	.sampler "UniformHandle"
	.handle  "TextureHandle"
	.flags   "uint32_t"

func.touch
	"void"
	.id "ViewId"

func.submit
	"void"
	.id            "ViewId"
	.program       "ProgramHandle"
	.depth         "uint32_t"
	.preserveState "bool"

func.submit { cname = "submit_occlusion_query" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.occlusionQuery "OcclusionQueryHandle"
	.depth          "uint32_t"
	.preserveState  "bool"

func.submit { cname = "submit_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"
	.depth          "uint32_t"
	.preserveState  "bool"

func.setBuffer { cname = "set_compute_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "VertexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_dynamic_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicIndexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_dynamic_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicVertexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_indirect_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndirectBufferHandle"
	.access "Access::Enum"

func.setImage
	"void"
	.stage  "uint8_t"
	.handle "TextureHandle"
	.mip    "uint8_t"
	.access "Access::Enum"
	.format "TextureFormat::Enum"

func.dispatch
	"void"
	.id      "ViewId"
	.program "ProgramHandle"
	.numX    "uint32_t"
	.numY    "uint32_t"
	.numZ    "uint32_t"

func.dispatch { cname = "dispatch_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"

func.discard
	"void"

func.blit
	"void"
	.id     "ViewId"
	.dst    "TextureHandle"
	.dstMip "uint8_t"
	.dstX   "uint16_t"
	.dstY   "uint16_t"
	.dstZ   "uint16_t"
	.src    "TextureHandle"
	.srcMip "uint8_t"      { default = 0 }
	.srcX   "uint16_t"     { default = 0 }
	.srcY   "uint16_t"     { default = 0 }
	.srcZ   "uint16_t"     { default = 0 }
	.width  "uint16_t"     { default = UINT16_MAX }
	.height "uint16_t"     { default = UINT16_MAX }
	.depth  "uint16_t"     { default = UINT16_MAX }
