-- vim: syntax=lua
-- bgfx interface

typedef "bool"
typedef "char"
typedef "float"
typedef "int8_t"
typedef "int32_t"
typedef "int64_t"
typedef "uint8_t"
typedef "uint16_t"
typedef "uint32_t"
typedef "uint64_t"
typedef "uintptr_t"
typedef "va_list"
typedef "void"

typedef "InternalData"
typedef "ViewId"
typedef "CallbackI" { cname = "callback_interface" }
typedef "bx::AllocatorI" { cname = "allocator_interface" }

--- Memory release callback.
funcptr.ReleaseFn
	"void"
	.ptr        "void*" --- Pointer to allocated data.
	.userData   "void*" --- User defined data if needed.

--- Fatal error enum.
enum.Fatal { underscore, comment = "" }
	.DebugCheck
	.InvalidShader
	.UnableToInitialize
	.UnableToCreateTexture
	.DeviceLost
	()	-- end of enum

--- Renderer backend type enum.
enum.RendererType { comment = "Renderer types:" }
	.Noop       --- No rendering.
	.Direct3D9  --- Direct3D 9.0
	.Direct3D11 --- Direct3D 11.0
	.Direct3D12 --- Direct3D 12.0
	.Gnm        --- GNM
	.Metal      --- Metal
	.OpenGLES   --- OpenGL ES 2.0+
	.OpenGL     --- OpenGL 2.1+
	.Vulkan     --- Vulkan
	()

--- Access mode enum.
enum.Access { comment = "Access:" }
	.Read      [[Read]]
	.Write     [[Write]]
	.ReadWrite [[Read and write]]


--- Vertex attribute enum.
enum.Attrib { comment = "Corresponds to vertex shader attribute." }
	.Position  [[a_position]]
	.Normal    [[a_normal]]
	.Tangent   [[a_tangent]]
	.Bitangent [[a_bitangent]]
	.Color0    [[a_color0]]
	.Color1    [[a_color1]]
	.Color2    [[a_color2]]
	.Color3    [[a_color3]]
	.Indices   [[a_indices]]
	.Weight    [[a_weight]]
	.TexCoord0 [[a_texcoord0]]
	.TexCoord1 [[a_texcoord1]]
	.TexCoord2 [[a_texcoord2]]
	.TexCoord3 [[a_texcoord3]]
	.TexCoord4 [[a_texcoord4]]
	.TexCoord5 [[a_texcoord5]]
	.TexCoord6 [[a_texcoord6]]
	.TexCoord7 [[a_texcoord7]]

--- Vertex attribute type enum.
enum.AttribType { comment = "Attribute types:" }
	.Uint8  [[Uint8]]
	.Uint10 [[Uint10, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_UINT10`.]]
	.Int16  [[Int16]]
	.Half   [[Half, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_HALF`.]]
	.Float  [[Float]]

--- Texture format enum.
---
--- Notation:
---
---       RGBA16S
---       ^   ^ ^
---       |   | +-- [ ]Unorm
---       |   |     [F]loat
---       |   |     [S]norm
---       |   |     [I]nt
---       |   |     [U]int
---       |   +---- Number of bits per component
---       +-------- Components
---
--- @attention Availability depends on Caps (see: formats).
enum.TextureFormat { comment = "Texture formats:" }
	.BC1          [[DXT1]]
	.BC2          [[DXT3]]
	.BC3          [[DXT5]]
	.BC4          [[LATC1/ATI1]]
	.BC5          [[LATC2/ATI2]]
	.BC6H         [[BC6H]]
	.BC7          [[BC7]]
	.ETC1         [[ETC1 RGB8]]
	.ETC2         [[ETC2 RGB8]]
	.ETC2A        [[ETC2 RGBA8]]
	.ETC2A1       [[ETC2 RGB8A1]]
	.PTC12        [[PVRTC1 RGB 2BPP]]
	.PTC14        [[PVRTC1 RGB 4BPP]]
	.PTC12A       [[PVRTC1 RGBA 2BPP]]
	.PTC14A       [[PVRTC1 RGBA 4BPP]]
	.PTC22        [[PVRTC2 RGBA 2BPP]]
	.PTC24        [[PVRTC2 RGBA 4BPP]]
	.ATC          [[ATC RGB 4BPP]]
	.ATCE         [[ATCE RGBA 8 BPP explicit alpha]]
	.ATCI         [[ATCI RGBA 8 BPP interpolated alpha]]
	-- todo: ASTC4X4 would be better
	.ASTC4x4      { cname = "ASTC4x4" } [[ASTC 4x4 8.0 BPP]]
	.ASTC5x5      { cname = "ASTC5x5" } [[ASTC 5x5 5.12 BPP]]
	.ASTC6x6      { cname = "ASTC6x6" } [[ASTC 6x6 3.56 BPP]]
	.ASTC8x5      { cname = "ASTC8x5" } [[ASTC 8x5 3.20 BPP]]
	.ASTC8x6      { cname = "ASTC8x6" } [[ASTC 8x6 2.67 BPP]]
	.ASTC10x5     { cname = "ASTC10x5" } [[ASTC 10x5 2.56 BPP]]
	.Unknown      [[Compressed formats above.]]
	.R1
	.A8
	.R8
	.R8I
	.R8U
	.R8S
	.R16
	.R16I
	.R16U
	.R16F
	.R16S
	.R32I
	.R32U
	.R32F
	.RG8
	.RG8I
	.RG8U
	.RG8S
	.RG16
	.RG16I
	.RG16U
	.RG16F
	.RG16S
	.RG32I
	.RG32U
	.RG32F
	.RGB8
	.RGB8I
	.RGB8U
	.RGB8S
	.RGB9E5F
	.BGRA8
	.RGBA8
	.RGBA8I
	.RGBA8U
	.RGBA8S
	.RGBA16
	.RGBA16I
	.RGBA16U
	.RGBA16F
	.RGBA16S
	.RGBA32I
	.RGBA32U
	.RGBA32F
	.R5G6B5
	.RGBA4
	.RGB5A1
	.RGB10A2
	.RG11B10F
	.UnknownDepth [[Depth formats below.]]
	.D16
	.D24
	.D24S8
	.D32
	.D16F
	.D24F
	.D32F
	.D0S8
	()

--- Uniform type enum.
enum.UniformType          { comment = "Uniform types:" }
	.Sampler [[Sampler.]]
	.End     [[Reserved, do not use.]]
	.Vec4    [[4 floats vector.]]
	.Mat3    [[3x3 matrix.]]
	.Mat4    [[4x4 matrix.]]

--- Backbuffer ratio enum.
enum.BackbufferRatio      { comment = "Backbuffer ratios:" }
	.Equal     [[Equal to backbuffer.]]
	.Half      [[One half size of backbuffer.]]
	.Quarter   [[One quarter size of backbuffer.]]
	.Eighth    [[One eighth size of backbuffer.]]
	.Sixteenth [[One sixteenth size of backbuffer.]]
	.Double    [[Double size of backbuffer.]]

--- Occlusion query result.
enum.OcclusionQueryResult { comment = "Occlusion query results:" }
	.Invisible [[Query failed test.]]
	.Visible   [[Query passed test.]]
	.NoResult  [[Query result is not available yet.]]

--- Primitive topology.
enum.Topology { underscore, comment = "Primitive topology:" }
	.TriList   [[Triangle list.]]
	.TriStrip  [[Triangle strip.]]
	.LineList  [[Line list.]]
	.LineStrip [[Line strip.]]
	.PointList [[Point list.]]

--- Topology conversion function.
enum.TopologyConvert { underscore , comment = "Topology conversion functions:" }
	.TriListFlipWinding  [[Flip winding order of triangle list.]]
	.TriStripFlipWinding [[Flip winding order of trinagle strip.]]
	.TriListToLineList   [[Convert triangle list to line list.]]
	.TriStripToTriList   [[Convert triangle strip to triangle list.]]
	.LineStripToLineList [[Convert line strip to line list.]]

--- Topology sort order.
enum.TopologySort { underscore, comment = "Topology sort order:" , }
	.DirectionFrontToBackMin
	.DirectionFrontToBackAvg
	.DirectionFrontToBackMax
	.DirectionBackToFrontMin
	.DirectionBackToFrontAvg
	.DirectionBackToFrontMax
	.DistanceFrontToBackMin
	.DistanceFrontToBackAvg
	.DistanceFrontToBackMax
	.DistanceBackToFrontMin
	.DistanceBackToFrontAvg
	.DistanceBackToFrontMax
	()

--- View mode sets draw call sort order.
enum.ViewMode { underscore, comment = "View modes:" }
	.Default         [[Default sort order.]]
	.Sequential      [[Sort in the same order in which submit calls were called.]]
	.DepthAscending   [[Sort draw call depth in ascending order.]]
	.DepthDescending  [[Sort draw call depth in descending order.]]

--- Render frame enum.
enum.RenderFrame { underscore, comment = "" }
	.NoContext
	.Render
	.Timeout
	.Exiting
	()

--- Platform data.
struct.PlatformData { ctor }
	.ndt          "void*" [[Native display type.]]
	.nwh          "void*" [[Native window handle.]]
	.context      "void*" [[GL context, or D3D device.]]
	.backBuffer   "void*" [[GL backbuffer, or D3D render target view.]]
	.backBufferDS "void*" [[Backbuffer depth/stencil.]]

--- Backbuffer resolution and reset parameters.
struct.Resolution { ctor }
	.format          "TextureFormat::Enum" [[Backbuffer format.]]
	.width           "uint32_t"            [[Backbuffer width.]]
	.height          "uint32_t"            [[Backbuffer height.]]
	.reset           "uint32_t"            [[Reset parameters.]]
	.numBackBuffers  "uint8_t"             [[Number of back buffers.]]
	.maxFrameLatency "uint8_t"             [[Maximum frame latency.]]

struct.Limits { namespace = "Init" }
	.maxEncoders    "uint16_t"             [[Maximum number of encoder threads.]]
	.transientVbSize "uint32_t"            [[Maximum transient vertex buffer size.]]
	.transientIbSize "uint32_t"            [[Maximum transient index buffer size.]]

--- Initialization parameters used by `bgfx::init`.
struct.Init { ctor }
	.type            "RendererType::Enum"  [[Select rendering backend. When set to RendererType::Count]]
	                                       [[a default rendering backend will be selected appropriate to the platform.]]
	                                       [[See: `bgfx::RendererType`]]

	.vendorId       "uint16_t"             [[Vendor PCI id. If set to `BGFX_PCI_ID_NONE` it will select the first]]
	                                       [[device.                                                             ]]
	                                       [[  - `BGFX_PCI_ID_NONE` - Autoselect adapter.                        ]]
	                                       [[  - `BGFX_PCI_ID_SOFTWARE_RASTERIZER` - Software rasterizer.        ]]
	                                       [[  - `BGFX_PCI_ID_AMD` - AMD adapter.                                ]]
	                                       [[  - `BGFX_PCI_ID_INTEL` - Intel adapter.                            ]]
	                                       [[  - `BGFX_PCI_ID_NVIDIA` - nVidia adapter.                          ]]

	.deviceId       "uint16_t"             [[Device id. If set to 0 it will select first device, or device with ]]
	                                       [[matching id. ]]

	.debug          "bool"                 [[Enable device for debuging.]]
	.profile        "bool"                 [[Enable device for profiling.]]
	.platformData   "PlatformData"         [[Platform data.]]
	.resolution     "Resolution"           [[Backbuffer resolution and reset parameters. See: `bgfx::Resolution`.]]
	.limits         "Limits"
	.callback       "CallbackI*"           [[Provide application specific callback interface.]]
	                                       [[See: `bgfx::CallbackI`]]

	.allocator      "bx::AllocatorI*"      [[Custom allocator. When a custom allocator is not    ]]
	                                       [[specified, bgfx uses the CRT allocator. Bgfx assumes]]
	                                       [[custom allocator is thread safe.                    ]]

--- Memory must be obtained by calling `bgfx::alloc`, `bgfx::copy`, or `bgfx::makeRef`.
---
--- @attention It is illegal to create this structure on stack and pass it to any bgfx API.
struct.Memory
	.data "uint8_t*" [[Pointer to data.]]
	.size "uint32_t" [[Data size.]]

--- GPU info.
struct.GPU  { namespace = "Caps" }
	.vendorId    "uint16_t"                [[Vendor PCI id. See `BGFX_PCI_ID_*`.]]
	.deviceId    "uint16_t"                [[Device id.]]

struct.Limits  { namespace = "Caps" }
	.maxDrawCalls            "uint32_t"    [[Maximum number of draw calls.                       ]]
	.maxBlits                "uint32_t"    [[Maximum number of blit calls.			     ]]
	.maxTextureSize          "uint32_t"    [[Maximum texture size.				     ]]
	.maxTextureLayers        "uint32_t"    [[Maximum texture layers.			     ]]
	.maxViews                "uint32_t"    [[Maximum number of views.			     ]]
	.maxFrameBuffers         "uint32_t"    [[Maximum number of frame buffer handles.	     ]]
	.maxFBAttachments        "uint32_t"    [[Maximum number of frame buffer attachments.	     ]]
	.maxPrograms             "uint32_t"    [[Maximum number of program handles.		     ]]
	.maxShaders              "uint32_t"    [[Maximum number of shader handles.		     ]]
	.maxTextures             "uint32_t"    [[Maximum number of texture handles.		     ]]
	.maxTextureSamplers      "uint32_t"    [[Maximum number of texture samplers.		     ]]
	.maxComputeBindings      "uint32_t"    [[Maximum number of compute bindings.		     ]]
	.maxVertexDecls          "uint32_t"    [[Maximum number of vertex format declarations.	     ]]
	.maxVertexStreams        "uint32_t"    [[Maximum number of vertex streams.		     ]]
	.maxIndexBuffers         "uint32_t"    [[Maximum number of index buffer handles.	     ]]
	.maxVertexBuffers        "uint32_t"    [[Maximum number of vertex buffer handles.	     ]]
	.maxDynamicIndexBuffers  "uint32_t"    [[Maximum number of dynamic index buffer handles.     ]]
	.maxDynamicVertexBuffers "uint32_t"    [[Maximum number of dynamic vertex buffer handles.    ]]
	.maxUniforms             "uint32_t"    [[Maximum number of uniform handles.		     ]]
	.maxOcclusionQueries     "uint32_t"    [[Maximum number of occlusion query handles.	     ]]
	.maxEncoders             "uint32_t"    [[Maximum number of encoder threads.		     ]]
	.transientVbSize         "uint32_t"    [[Maximum transient vertex buffer size.		     ]]
	.transientIbSize         "uint32_t"    [[Maximum transient index buffer size.		     ]]

--- Renderer capabilities.
struct.Caps
	.rendererType "RendererType::Enum"     [[Renderer backend type. See: `bgfx::RendererType`]]

	.supported    "uint64_t"               [[Supported functionality.                                                                      ]]
	                                       [[                                                                                              ]]
	                                       [[@attention See BGFX_CAPS_* flags at https://bkaradzic.github.io/bgfx/bgfx.html#available-caps ]]
	.vendorId     "uint16_t"               [[Selected GPU vendor PCI id.]]
	.deviceId     "uint16_t"               [[Selected GPU device id.]]
	.homogeneousDepth "bool"               [[True when NDC depth is in [-1, 1] range, otherwise its [0, 1].]]
	.originBottomLeft "bool"               [[True when NDC origin is at bottom left.]]
	.numGPUs      "uint8_t"                [[Number of enumerated GPUs.]]
	.gpu          "GPU[4]"                 [[Enumerated GPUs.]]
	.limits       "Limits"
	.formats      "uint16_t[TextureFormat::Count]"
		[[Supported texture format capabilities flags:                                               ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_NONE` - Texture format is not supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D_SRGB` - Texture as sRGB format is supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_2D_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D_SRGB` - Texture as sRGB format is supported.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_3D_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE` - Texture format is supported.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_SRGB` - Texture as sRGB format is supported.	     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_EMULATED` - Texture format is emulated.		     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_VERTEX` - Texture format can be used from vertex shader.     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_IMAGE` - Texture format can be used as image from compute    ]]
		[[    shader.										     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER` - Texture format can be used as frame	     ]]
		[[    buffer.										     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER_MSAA` - Texture format can be used as MSAA	     ]]
		[[    frame buffer.									     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_MSAA` - Texture can be sampled as MSAA.			     ]]
		[[  - `BGFX_CAPS_FORMAT_TEXTURE_MIP_AUTOGEN` - Texture format supports auto-generated	     ]]
		[[    mips.										     ]]

--- Transient index buffer.
struct.TransientIndexBuffer
	.data       "int8_t*"           [[Pointer to data.]]
	.size       "uint32_t"          [[Data size.]]
	.startIndex "uint32_t"          [[First index.]]
	.handle     "IndexBufferHandle" [[Index buffer handle.]]

--- Transient vertex buffer.
struct.TransientVertexBuffer
	.data        "int8_t*"            [[Pointer to data.]]
	.size        "uint32_t"           [[Data size.]]
	.startVertex "uint32_t"           [[First vertex.]]
	.stride      "uint16_t"           [[Vertex stride.]]
	.handle      "VertexBufferHandle" [[Vertex buffer handle.]]
	.decl        "VertexDeclHandle"   [[Vertex declaration handle.]]

--- Instance data buffer info.
struct.InstanceDataBuffer
	.data   "int8_t*"            [[Pointer to data.]]
	.size   "uint32_t"           [[Data size.]]
	.offset "uint32_t"           [[Offset in vertex buffer.]]
	.num    "uint32_t"           [[Number of instances.]]
	.stride "uint16_t"           [[Vertex buffer stride.]]
	.handle "VertexBufferHandle" [[Vertex buffer object handle.]]

--- Texture info.
struct.TextureInfo
	.format       "TextureFormat::Enum" [[Texture format.]]
	.storageSize  "uint32_t"            [[Total amount of bytes required to store texture.]]
	.width        "uint16_t"            [[Texture width.]]
	.height       "uint16_t"            [[Texture height.]]
	.depth        "uint16_t"            [[Texture depth.]]
	.numLayers    "uint16_t"            [[Number of layers in texture array.]]
	.numMips      "uint8_t"             [[Number of MIP maps.]]
	.bitsPerPixel "uint8_t"             [[Format bits per pixel.]]
	.cubeMap      "bool"                [[Texture is cubemap.]]

--- Uniform info.
struct.UniformInfo
	.name "char[256]"         [[Uniform name.]]
	.type "UniformType::Enum" [[Uniform type.]]
	.num  "uint16_t"          [[Number of elements in array.]]

--- Frame buffer texture attachment info.
struct.Attachment
	.access  "Access::Enum"  [[Attachement access. See `Access::Enum`.]]
	.handle  "TextureHandle" [[Render target texture handle.]]
	.mip     "uint16_t"      [[Mip level.]]
	.layer   "uint16_t"      [[Cubemap side or depth layer/slice.]]
	.resolve "uint8_t"       [[Resolve flags. See: `BGFX_RESOLVE_*`]]

--- Transform data.
struct.Transform
	.data "float*"  [[Pointer to first 4x4 matrix.]]
	.num "uint16_t" [[Number of matrices.]]

--- View stats.
struct.ViewStats
	.name           "char[256]" [[View name.]]
	.view           "ViewId"    [[View id.]]
	.cpuTimeElapsed "int64_t"   [[CPU (submit) time elapsed.]]
	.gpuTimeElapsed "int64_t"   [[GPU time elapsed.]]

--- Encoder stats.
struct.EncoderStats
	.cpuTimeBegin "int64_t" [[Encoder thread CPU submit begin time.]]
	.cpuTimeEnd   "int64_t" [[Encoder thread CPU submit end time.]]

--- Renderer statistics data.
---
--- @remarks All time values are high-resolution timestamps, while
--- time frequencies define timestamps-per-second for that hardware.
struct.Stats
	.cpuTimeFrame            "int64_t"       [[CPU time between two `bgfx::frame` calls.]]
	.cpuTimeBegin            "int64_t"       [[Render thread CPU submit begin time.]]
	.cpuTimeEnd              "int64_t"       [[Render thread CPU submit end time.]]
	.cpuTimerFreq            "int64_t"       [[CPU timer frequency. Timestamps-per-second]]

	.gpuTimeBegin            "int64_t"       [[GPU frame begin time.]]
	.gpuTimeEnd              "int64_t"       [[GPU frame end time.]]
	.gpuTimerFreq            "int64_t"       [[GPU timer frequency.]]

	.waitRender              "int64_t"       [[Time spent waiting for render backend thread to finish issuing draw commands to underlying graphics API.]]
	.waitSubmit              "int64_t"       [[Time spent waiting for submit thread to advance to next frame.]]

	.numDraw                 "uint32_t"      [[Number of draw calls submitted.]]
	.numCompute              "uint32_t"      [[Number of compute calls submitted.]]
	.numBlit                 "uint32_t"      [[Number of blit calls submitted.]]
	.maxGpuLatency           "uint32_t"      [[GPU driver latency.]]

	.numDynamicIndexBuffers  "uint16_t"      [[Number of used dynamic index buffers.]]
	.numDynamicVertexBuffers "uint16_t"      [[Number of used dynamic vertex buffers.]]
	.numFrameBuffers         "uint16_t"      [[Number of used frame buffers.]]
	.numIndexBuffers         "uint16_t"      [[Number of used index buffers.]]
	.numOcclusionQueries     "uint16_t"      [[Number of used occlusion queries.]]
	.numPrograms             "uint16_t"      [[Number of used programs.]]
	.numShaders              "uint16_t"      [[Number of used shaders.]]
	.numTextures             "uint16_t"      [[Number of used textures.]]
	.numUniforms             "uint16_t"      [[Number of used uniforms.]]
	.numVertexBuffers        "uint16_t"      [[Number of used vertex buffers.]]
	.numVertexDecls          "uint16_t"      [[Number of used vertex declarations.]]

	.textureMemoryUsed       "int64_t"       [[Estimate of texture memory used.]]
	.rtMemoryUsed            "int64_t"       [[Estimate of render target memory used.]]
	.transientVbUsed         "int32_t"       [[Amount of transient vertex buffer used.]]
	.transientIbUsed         "int32_t"       [[Amount of transient index buffer used.]]

	.numPrims                "uint32_t[Topology::Count]"      [[Number of primitives rendered.]]

	.gpuMemoryMax            "int64_t"       [[Maximum available GPU memory for application.]]
	.gpuMemoryUsed           "int64_t"       [[Amount of GPU memory used by the application.]]

	.width                   "uint16_t"      [[Backbuffer width in pixels.]]
	.height                  "uint16_t"      [[Backbuffer height in pixels.]]
	.textWidth               "uint16_t"      [[Debug text width in characters.]]
	.textHeight              "uint16_t"      [[Debug text height in characters.]]

	.numViews                "uint16_t"      [[Number of view stats.]]
	.viewStats               "ViewStats*"    [[Array of View stats.]]

	.numEncoders             "uint8_t"       [[Number of encoders used during frame.]]
	.encoderStats            "EncoderStats*" [[Array of encoder stats.]]

--- Vertex declaration.
struct.VertexDecl { ctor }
	.hash                    "uint32_t"
	.stride                  "uint16_t"
	.offset                  "uint16_t[Attrib::Count]"
	.attributes              "uint16_t[Attrib::Count]"

--- Encoders are used for submitting draw calls from multiple threads. Only one encoder
--- per thread should be used. Use `bgfx::begin()` to obtain an encoder for a thread.
struct.Encoder {}

handle "DynamicIndexBufferHandle"
handle "DynamicVertexBufferHandle"
handle "FrameBufferHandle"
handle "IndexBufferHandle"
handle "IndirectBufferHandle"
handle "OcclusionQueryHandle"
handle "ProgramHandle"
handle "ShaderHandle"
handle "TextureHandle"
handle "UniformHandle"
handle "VertexBufferHandle"
handle "VertexDeclHandle"

--- Start VertexDecl.
func.VertexDecl.begin
	"void"
	.rendererType    "RendererType::Enum"

--- Add attribute to VertexDecl.
---
--- @remarks Must be called between begin/end.
---
func.VertexDecl.add
	"void"
	.attrib          "Attrib::Enum"     --- Attribute semantics. See: `bgfx::Attrib`
	.num             "uint8_t"          --- Number of elements 1, 2, 3 or 4.
	.type            "AttribType::Enum" --- Element type.
	.normalized      "bool"             --- When using fixed point AttribType (f.e. Uint8)
	                                    --- value will be normalized for vertex shader usage. When normalized
	                                    --- is set to true, AttribType::Uint8 value in range 0-255 will be
	                                    --- in range 0.0-1.0 in vertex shader.
	.asInt           "bool"             --- Packaging rule for vertexPack, vertexUnpack, and
	                                    --- vertexConvert for AttribType::Uint8 and AttribType::Int16.
	                                    --- Unpacking code must be implemented inside vertex shader.

--- Decode attribute.
func.VertexDecl.decode { const }
	"void"
	.attrib     "Attrib::Enum"               --- Attribute semantics. See: `bgfx::Attrib`
	.num        "uint8_t &"          { out } --- Number of elements.
	.type       "AttribType::Enum &" { out } --- Element type.
	.normalized "bool &"             { out }
	.asInt      "bool &"             { out }

--- Returns true if VertexDecl contains attribute.
func.VertexDecl.has { const }
	"bool"
	.attrib "Attrib::Enum" --- Attribute semantics. See: `bgfx::Attrib`

--- Skip `_num` bytes in vertex stream.
func.VertexDecl.skip
	"void"
	.num "uint8_t"

-- Notice: `end` is a keyword in lua.
func.VertexDecl["end"] { comment = "End VertexDecl." }
	"void"

--- Returns relative attribute offset from the vertex.
func.VertexDecl.getOffset { const , cpponly }
	"uint16_t"
	.attrib    "Attrib::Enum" --- Attribute semantics. See: `bgfx::Attrib`

--- Returns vertex stride.
func.VertexDecl.getStride { const , cpponly }
	"uint16_t"

--- Returns size of vertex buffer for number of vertices.
func.VertexDecl.getSize { const, cpponly }
	"uint32_t"
	.num       "uint32_t"

--- Pack vertex attribute into vertex stream format.
func.vertexPack
	"void"
	.input           "const float[4]"     --- Value to be packed into vertex stream.
	.inputNormalized "bool"               --- `true` if input value is already normalized.
	.attr            "Attrib::Enum"       --- Attribute to pack.
	.decl            "const VertexDecl &" --- Vertex stream declaration.
	.data            "void*"              --- Destination vertex stream where data will be packed.
	.index           "uint32_t"           --- Vertex index that will be modified.

--- Unpack vertex attribute from vertex stream format.
func.vertexUnpack
	"void"
	.output "float[4]" { out }   --- Result of unpacking.
	.attr   "Attrib::Enum"       --- Attribute to unpack.
	.decl   "const VertexDecl &" --- Vertex stream declaration.
	.data   "const void*"        --- Source vertex stream from where data will be unpacked.
	.index  "uint32_t"           --- Vertex index that will be unpacked.

--- Converts vertex stream data from one vertex stream format to another.
func.vertexConvert
	"void"
	.dstDecl "const VertexDecl &" --- Destination vertex stream declaration.
	.dstData "void*"              --- Destination vertex stream.
	.srcDecl "const VertexDecl &" --- Source vertex stream declaration.
	.srcData "const void*"        --- Source vertex stream data.
	.num     "uint32_t"           --- Number of vertices to convert from source to destination.

--- Weld vertices.
func.weldVertices
	"uint16_t"                    --- Number of unique vertices after vertex welding.
	.output  "uint16_t*"          --- Welded vertices remapping table. The size of buffer
	                              --- must be the same as number of vertices.
	.decl    "const VertexDecl &" --- Vertex stream declaration.
	.data    "const void*"        --- Vertex stream.
	.num     "uint16_t"           --- Number of vertices in vertex stream.
	.epsilon "float"              --- Error tolerance for vertex position comparison.

--- Convert index buffer for use with different primitive topologies.
func.topologyConvert
	"uint32_t"                          --- Number of output indices after conversion.
	.conversion "TopologyConvert::Enum" --- Conversion type, see `TopologyConvert::Enum`.
	.dst        "void*" { out }         --- Destination index buffer. If this argument is NULL
	                                    --- function will return number of indices after conversion.
	.dstSize    "uint32_t"              --- Destination index buffer in bytes. It must be
	                                    --- large enough to contain output indices. If destination size is
	                                    --- insufficient index buffer will be truncated.
	.indices    "const void*"           --- Source indices.
	.numIndices "uint32_t"              --- Number of input indices.
	.index32    "bool"                  --- Set to `true` if input indices are 32-bit.

--- Sort indices.
func.topologySortTriList
	"void"
	.sort       "TopologySort::Enum" --- Sort order, see `TopologySort::Enum`.
	.dst        "void*" { out }      --- Destination index buffer.
	.dstSize    "uint32_t"           --- Destination index buffer in bytes. It must be
	                                 --- large enough to contain output indices. If destination size is
	                                 --- insufficient index buffer will be truncated.
	.dir        "const float[3]"     --- Direction (vector must be normalized).
	.pos        "const float[3]"     --- Position.
	.vertices   "const void*"        --- Pointer to first vertex represented as
	                                 --- float x, y, z. Must contain at least number of vertices
	                                 --- referencende by index buffer.
	.stride     "uint32_t"           --- Vertex stride.
	.indices    "const void*"        --- Source indices.
	.numIndices "uint32_t"           --- Number of input indices.
	.index32    "bool"               --- Set to `true` if input indices are 32-bit.

--- Returns supported backend API renderers.
func.getSupportedRenderers
	"uint8_t"                             --- Number of supported renderers.
	.max  "uint8_t"                       --- Maximum number of elements in _enum array.
	.enum "RendererType::Enum*" { inout } --- Array where supported renderers will be written.

--- Returns name of renderer.
func.getRendererName
	"const char*"              --- Name of renderer.
	.type "RendererType::Enum" --- Renderer backend type. See: `bgfx::RendererType`

func.initCtor { cfunc }
	"void"
	.init "Init*"

--- Initialize bgfx library.
func.init { cfunc }
	"bool"               --- `true` if initialization was successful.
	.init "const Init &" --- Initialization parameters. See: `bgfx::Init` for more info.

--- Shutdown bgfx library.
func.shutdown
	"void"

--- Reset graphic settings and back-buffer size.
---
--- @attention This call doesn't actually change window size, it just
---   resizes back-buffer. Windowing code has to change window size.
---
func.reset
	"void"
	.width  "uint32_t"            --- Back-buffer width.
	.height "uint32_t"            --- Back-buffer height.
	.flags  "uint32_t"            --- See: `BGFX_RESET_*` for more info.
	                              ---   - `BGFX_RESET_NONE` - No reset flags.
	                              ---   - `BGFX_RESET_FULLSCREEN` - Not supported yet.
	                              ---   - `BGFX_RESET_MSAA_X[2/4/8/16]` - Enable 2, 4, 8 or 16 x MSAA.
	                              ---   - `BGFX_RESET_VSYNC` - Enable V-Sync.
	                              ---   - `BGFX_RESET_MAXANISOTROPY` - Turn on/off max anisotropy.
	                              ---   - `BGFX_RESET_CAPTURE` - Begin screen capture.
	                              ---   - `BGFX_RESET_FLUSH_AFTER_RENDER` - Flush rendering after submitting to GPU.
	                              ---   - `BGFX_RESET_FLIP_AFTER_RENDER` - This flag  specifies where flip
	                              ---     occurs. Default behavior is that flip occurs before rendering new
	                              ---     frame. This flag only has effect when `BGFX_CONFIG_MULTITHREADED=0`.
	                              ---   - `BGFX_RESET_SRGB_BACKBUFFER` - Enable sRGB backbuffer.
	.format "TextureFormat::Enum" --- Texture format. See: `TextureFormat::Enum`.

--- Advance to next frame. When using multithreaded renderer, this call
--- just swaps internal buffers, kicks render thread, and returns. In
--- singlethreaded renderer this call does frame rendering.
func.frame
	"uint32_t"                           --- Current frame number. This might be used in conjunction with
	                                     --- double/multi buffering data outside the library and passing it to
	                                     --- library via `bgfx::makeRef` calls.
	.capture "bool"  { default = false } --- Capture frame with graphics debugger.

--- Returns current renderer backend API type.
---
--- @remarks
---   Library must be initialized.
---
func.getRendererType
	"RendererType::Enum" --- Renderer backend type. See: `bgfx::RendererType`

--- Returns renderer capabilities.
---
--- @remarks
---   Library must be initialized.
---
func.getCaps
	"const Caps*" --- Pointer to static `bgfx::Caps` structure.

--- Returns performance counters.
---
--- @attention Pointer returned is valid until `bgfx::frame` is called.
---
func.getStats
	"const Stats*" -- Performance counters.

--- Allocate buffer to pass to bgfx calls. Data will be freed inside bgfx.
func.alloc
	"const Memory*"  --- Allocated memory.
	.size "uint32_t" --- Size to allocate.

--- Allocate buffer and copy data into it. Data will be freed inside bgfx.
func.copy
	"const Memory*"     --- Allocated memory.
	.data "const void*" --- Pointer to data to be copied.
	.size "uint32_t"    --- Size of data to be copied.

--- Make reference to data to pass to bgfx. Unlike `bgfx::alloc`, this call
--- doesn't allocate memory for data. It just copies the _data pointer. You
--- can pass `ReleaseFn` function pointer to release this memory after it's
--- consumed, otherwise you must make sure _data is available for at least 2
--- `bgfx::frame` calls. `ReleaseFn` function must be able to be called
--- from any thread.
---
--- @attention Data passed must be available for at least 2 `bgfx::frame` calls.
---
func.makeRef { conly }
	"const Memory*"     --- Referenced memory.
	.data "const void*" --- Pointer to data.
	.size "uint32_t"    --- Size of data.

--- Make reference to data to pass to bgfx. Unlike `bgfx::alloc`, this call
--- doesn't allocate memory for data. It just copies the _data pointer. You
--- can pass `ReleaseFn` function pointer to release this memory after it's
--- consumed, otherwise you must make sure _data is available for at least 2
--- `bgfx::frame` calls. `ReleaseFn` function must be able to be called
--- from any thread.
---
--- @attention Data passed must be available for at least 2 `bgfx::frame` calls.
---
func.makeRef { cname = "make_ref_release" }
	"const Memory*"                           --- Referenced memory.
	.data      "const void*"                  --- Pointer to data.
	.size      "uint32_t"                     --- Size of data.
	.releaseFn "ReleaseFn" { default = NULL } --- Callback function to release memory after use.
	.userData  "void*" { default = NULL }     --- User data to be passed to callback function.

--- Set debug flags.
func.setDebug
	"void"
	.debug "uint32_t" --- Available flags:
	                  ---   - `BGFX_DEBUG_IFH` - Infinitely fast hardware. When this flag is set
	                  ---     all rendering calls will be skipped. This is useful when profiling
	                  ---     to quickly assess potential bottlenecks between CPU and GPU.
	                  ---   - `BGFX_DEBUG_PROFILER` - Enable profiler.
	                  ---   - `BGFX_DEBUG_STATS` - Display internal statistics.
	                  ---   - `BGFX_DEBUG_TEXT` - Display debug text.
	                  ---   - `BGFX_DEBUG_WIREFRAME` - Wireframe rendering. All rendering
	                  ---     primitives will be rendered as lines.

--- Clear internal debug text buffer.
func.dbgTextClear
	"void"
	.attr  "uint8_t" --- Background color.
	.small "bool"    --- Default or 8x8 font.

--- Print formatted data to internal debug text character-buffer (VGA-compatible text mode).
func.dbgTextPrintf { vararg = "dbgTextPrintfVargs" }
	"void"
	.x      "uint16_t"    --- Position x from the left corner of the window.
	.y      "uint16_t"    --- Position y from the top corner of the window.
	.attr   "uint8_t"     --- Color palette. Where top 4-bits represent index of background, and bottom
	                      --- 4-bits represent foreground color from standard VGA text palette (ANSI escape codes).
	.format "const char*" --- `printf` style format.

--- Print formatted data from variable argument list to internal debug text character-buffer (VGA-compatible text mode).
func.dbgTextPrintfVargs { cname = "dbg_text_vprintf" }
	"void"
	.x       "uint16_t"    --- Position x from the left corner of the window.
	.y       "uint16_t"    --- Position y from the top corner of the window.
	.attr    "uint8_t"     --- Color palette. Where top 4-bits represent index of background, and bottom
                           --- 4-bits represent foreground color from standard VGA text palette (ANSI escape codes).
	.format  "const char*" --- `printf` style format.
	.argList "va_list"     --- Variable arguments list for format string.

--- Draw image into internal debug text buffer.
func.dbgTextImage
	"void"
	.x       "uint16_t"    --- Position x from the left corner of the window.
	.y       "uint16_t"    --- Position y from the top corner of the window.
	.width   "uint16_t"    --- Image width.
	.height  "uint16_t"    --- Image height.
	.data    "const void*" --- Raw image data (character/attribute raw encoding).
	.pitch   "uint16_t"    --- Image pitch in bytes.

--- Create static index buffer.
func.createIndexBuffer
	"IndexBufferHandle"
	.mem   "const Memory*" --- Index buffer data.
	.flags "uint16_t"      --- Buffer creation flags.
	                       ---   - `BGFX_BUFFER_NONE` - No flags.
	                       ---   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                       ---   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                       ---       is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                       ---   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                       ---   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                       ---       data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                       ---       will be trimmed to fit the existing buffer size. This flag has effect only on dynamic
	                       ---       buffers.
	                       ---   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on
	                       ---       index buffers.

--- Set static index buffer debug name.
func.setName { cname = "set_index_buffer_name" }
	"void"
	.handle "IndexBufferHandle" --- Static index buffer handle.
	.name   "const char*"       --- Static index buffer name.
	.len    "int32_t"           --- Static index buffer name length (if length is INT32_MAX, it's expected
	                            --- that _name is zero terminated string.

--- Destroy static index buffer.
func.destroy { cname = "destroy_index_buffer" }
	"void"
	.handle "IndexBufferHandle" --- Static index buffer handle.

--- Create static vertex buffer.
func.createVertexBuffer
	"VertexBufferHandle"        --- Static vertex buffer handle.
	.mem   "const Memory*"      --- Vertex buffer data.
	.decl  "const VertexDecl &" --- Vertex declaration.
	.flags "uint16_t"           --- Buffer creation flags.
	                            ---  - `BGFX_BUFFER_NONE` - No flags.
	                            ---  - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                            ---  - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                            ---      is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                            ---  - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                            ---  - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                            ---      data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                            ---      will be trimmed to fit the existing buffer size. This flag has effect only on dynamic buffers.
	                            ---  - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on index buffers.

--- Set static vertex buffer debug name.
func.setName { cname = "set_vertex_buffer_name" }
	"void"
	.handle "VertexBufferHandle" --- Static vertex buffer handle.
	.name   "const char*"        --- Static vertex buffer name.
	.len    "int32_t"            --- Static vertex buffer name length (if length is INT32_MAX, it's expected
	                             --- that _name is zero terminated string.

--- Destroy static vertex buffer.
func.destroy { cname = "destroy_vertex_buffer" }
	"void"
	.handle "VertexBufferHandle" --- Static vertex buffer handle.

--- Create empty dynamic index buffer.
func.createDynamicIndexBuffer
	"DynamicIndexBufferHandle" --- Dynamic index buffer handle.
	.num   "uint32_t"          --- Number of indices.
	.flags "uint16_t"          --- Buffer creation flags.
	                           ---   - `BGFX_BUFFER_NONE` - No flags.
	                           ---   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                           ---   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                           ---       is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                           ---   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                           ---   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                           ---       data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                           ---       will be trimmed to fit the existing buffer size. This flag has effect only on dynamic
	                           ---       buffers.
	                           ---   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on
	                           ---       index buffers.

--- Create dynamic index buffer and initialized it.
func.createDynamicIndexBuffer { cname = "create_dynamic_index_buffer_mem" }
	"DynamicIndexBufferHandle" --- Dynamic index buffer handle.
	.mem   "const Memory*"     --- Index buffer data.
	.flags "uint16_t"          --- Buffer creation flags.
	                           ---   - `BGFX_BUFFER_NONE` - No flags.
	                           ---   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                           ---   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                           ---       is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                           ---   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                           ---   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                           ---       data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                           ---       will be trimmed to fit the existing buffer size. This flag has effect only on dynamic
	                           ---       buffers.
	                           ---   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on
	                           ---       index buffers.

--- Update dynamic index buffer.
func.update { cname = "update_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle" --- Dynamic index buffer handle.
	.startIndex "uint32_t"                 --- Start index.
	.mem        "const Memory*"            --- Index buffer data.

--- Destroy dynamic index buffer.
func.destroy { cname = "destroy_dynamic_index_buffer" }
	"void"
	.handle "DynamicIndexBufferHandle" --- Dynamic index buffer handle.

--- Create empty dynamic vertex buffer.
func.createDynamicVertexBuffer
	"DynamicVertexBufferHandle" --- Dynamic vertex buffer handle.
	.num   "uint32_t"           --- Number of vertices.
	.decl  "const VertexDecl&"  --- Vertex declaration.
	.flags "uint16_t"           --- Buffer creation flags.
	                            ---   - `BGFX_BUFFER_NONE` - No flags.
	                            ---   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                            ---   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                            ---       is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                            ---   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                            ---   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                            ---       data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                            ---       will be trimmed to fit the existing buffer size. This flag has effect only on dynamic
	                            ---       buffers.
	                            ---   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on
	                            ---       index buffers.

--- Create dynamic vertex buffer and initialize it.
func.createDynamicVertexBuffer { cname = "create_dynamic_vertex_buffer_mem" }
	"DynamicVertexBufferHandle" --- Dynamic vertex buffer handle.
	.mem   "const Memory*"      --- Vertex buffer data.
	.decl  "const VertexDecl&"  --- Vertex declaration.
	.flags "uint16_t"           --- Buffer creation flags.
	                            ---   - `BGFX_BUFFER_NONE` - No flags.
	                            ---   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.
	                            ---   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer
	                            ---       is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.
	                            ---   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.
	                            ---   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of
	                            ---       data is passed. If this flag is not specified, and more data is passed on update, the buffer
	                            ---       will be trimmed to fit the existing buffer size. This flag has effect only on dynamic
	                            ---       buffers.
	                            ---   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on
	                            ---       index buffers.

--- Update dynamic vertex buffer.
func.update { cname = "update_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle" --- Dynamic vertex buffer handle.
	.startVertex "uint32_t"                  --- Start vertex.
	.mem         "const Memory*"             --- Vertex buffer data.

--- Destroy dynamic vertex buffer.
func.destroy { cname = "destroy_dynamic_vertex_buffer" }
	"void"
	.handle "DynamicVertexBufferHandle" --- Dynamic vertex buffer handle.

--- Returns number of requested or maximum available indices.
func.getAvailTransientIndexBuffer
	"uint32_t"      --- Number of requested or maximum available indices.
	.num "uint32_t" --- Number of required indices.

--- Returns number of requested or maximum available vertices.
func.getAvailTransientVertexBuffer
	"uint32_t"                  --- Number of requested or maximum available vertices.
	.num "uint32_t"             --- Number of required vertices.
	.decl  "const VertexDecl &" --- Vertex declaration.

func.getAvailInstanceDataBuffer
	"uint32_t"
	.num    "uint32_t"
	.stride "uint16_t"

func.allocTransientIndexBuffer
	"void"
	.tib "TransientIndexBuffer*" { out }
	.num "uint32_t"

func.allocTransientVertexBuffer
	"void"
	.tvb  "TransientVertexBuffer*" { out }
	.num  "uint32_t"
	.decl "const VertexDecl &"

func.allocTransientBuffers
	"bool"
	.tvb         "TransientVertexBuffer*" { out }
	.decl        "const VertexDecl &"
	.numVertices "uint32_t"
	.tib         "TransientIndexBuffer*" { out }
	.numIndices  "uint32_t"

func.allocInstanceDataBuffer
	"void"
	.idb    "InstanceDataBuffer*" { out }
	.num    "uint32_t"
	.stride "uint16_t"

func.createIndirectBuffer
	"IndirectBufferHandle"
	.num "uint32_t"

func.destroy { cname = "destroy_indirect_buffer" }
	"void"
	.handle "IndirectBufferHandle"

func.createShader
	"ShaderHandle"
	.mem "const Memory*"

func.getShaderUniforms
	"uint16_t"
	.handle   "ShaderHandle"
	.uniforms "UniformHandle*" { out }
	.max      "uint16_t"

func.setName { cname = "set_shader_name" }
	"void"
	.handle "ShaderHandle"
	.name   "const char*"
	.len    "int32_t"

func.destroy { cname = "destroy_shader" }
	"void"
	.handle "ShaderHandle"

func.createProgram
	"ProgramHandle"
	.vsh "ShaderHandle"
	.fsh "ShaderHandle"
	.destroyShaders "bool"

func.createProgram { cname = "create_compute_program" }
	"ProgramHandle"
	.csh "ShaderHandle"
	.destroyShaders "bool"

func.destroy { cname = "destroy_program" }
	"void"
	.handle "ProgramHandle"

func.isTextureValid
	"bool"
	.depth     "uint16_t"
	.cubeMap   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"

func.calcTextureSize
	"void"
	.info      "TextureInfo &" { out }
	.width     "uint16_t"
	.height    "uint16_t"
	.depth     "uint16_t"
	.cubeMap   "bool"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"

func.createTexture
	"TextureHandle"
	.mem   "const Memory*"
	.flags "uint64_t"
	.skip  "uint8_t"
	.info  "TextureInfo*" { out }

func.createTexture2D
	"TextureHandle"
	.width     "uint16_t"
	.height    "uint16_t"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.createTexture2D { cname = "create_texture_2d_scaled" }
	"TextureHandle"
	.ratio     "BackbufferRatio::Enum"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"

func.createTexture3D
	"TextureHandle"
	.width     "uint16_t"
	.height    "uint16_t"
	.depth     "uint16_t"
	.hasMips   "bool"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.createTextureCube
	"TextureHandle"
	.size      "uint16_t"
	.hasMips   "bool"
	.numLayers "uint16_t"
	.format    "TextureFormat::Enum"
	.flags     "uint64_t"
	.mem       "const Memory*"

func.updateTexture2D
	"void"
	.handle "TextureHandle"
	.layer  "uint16_t"
	.mip    "uint8_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.mem    "const Memory*"
	.pitch  "uint16_t"

func.updateTexture3D
	"void"
	.handle "TextureHandle"
	.mip    "uint8_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.z      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.depth  "uint16_t"
	.mem    "const Memory*"

func.updateTextureCube
	"void"
	.handle "TextureHandle"
	.layer  "uint16_t"
	.side   "uint8_t"
	.mip    "uint8_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.mem    "const Memory*"
	.pitch  "uint16_t"

func.readTexture
	"uint32_t"
	.handle "TextureHandle"
	.data   "void*"
	.mip    "uint8_t"

func.setName { cname = "set_texture_name" }
	"void"
	.handle "TextureHandle"
	.name   "const char*"
	.len    "int32_t"

func.getDirectAccessPtr
	"void*"
	.handle "TextureHandle"

func.destroy { cname = "destroy_texture" }
	"void"
	.handle "TextureHandle"

func.createFrameBuffer
	"FrameBufferHandle"
	.width        "uint16_t"
	.height       "uint16_t"
	.format       "TextureFormat::Enum"
	.textureFlags "uint64_t"

func.createFrameBuffer { cname = "create_frame_buffer_scaled" }
	"FrameBufferHandle"
	.ratio        "BackbufferRatio::Enum"
	.format       "TextureFormat::Enum"
	.textureFlags "uint64_t"

func.createFrameBuffer { cname = "create_frame_buffer_from_handles" }
	"FrameBufferHandle"
	.num            "uint8_t"
	.handles        "const TextureHandle*"
	.destroyTexture "bool"

func.createFrameBuffer { cname = "create_frame_buffer_from_attachment" }
	"FrameBufferHandle"
	.num            "uint8_t"
	.handles        "const Attachment*"
	.destroyTexture "bool"

func.createFrameBuffer { cname = "create_frame_buffer_from_nwh" }
	"FrameBufferHandle"
	.nwh         "void*"
	.width       "uint16_t"
	.height      "uint16_t"
	.format      "TextureFormat::Enum"
	.depthFormat "TextureFormat::Enum"

func.setName { cname = "set_frame_buffer_name" }
	"void"
	.handle "FrameBufferHandle"
	.name   "const char*"
	.len    "int32_t"

func.getTexture
	"TextureHandle"
	.handle     "FrameBufferHandle"
	.attachment "uint8_t"

func.destroy { cname = "destroy_frame_buffer" }
	"void"
	.handle "FrameBufferHandle"

func.createUniform
	"UniformHandle"
	.name "const char*"
	.type "UniformType::Enum"
	.num  "uint16_t"

func.getUniformInfo
	"void"
	.handle "UniformHandle"
	.info   "UniformInfo &" { out }

func.destroy { cname = "destroy_uniform" }
	"void"
	.handle "UniformHandle"

func.createOcclusionQuery
	"OcclusionQueryHandle"

func.getResult
	"OcclusionQueryResult::Enum"
	.handle "OcclusionQueryHandle"
	.result "int32_t*" { out }

func.destroy { cname = "destroy_occlusion_query" }
	"void"
	.handle "OcclusionQueryHandle"

func.setPaletteColor
	"void"
	.index "uint8_t"
	.rgba  "const float[4]"

--- Set view name.
---
--- @remarks
---   This is debug only feature.
---
---   In graphics debugger view name will appear as:
---
---       "nnnc <view name>"
---        ^  ^ ^
---        |  +--- compute (C)
---        +------ view id
---
func.setViewName
	"void"
	.id   "ViewId"      --- View id.
	.name "const char*" --- View name.

--- Set view rectangle. Draw primitive outside view will be clipped.
func.setViewRect
	"void"
	.id     "ViewId"   --- View id.
	.x      "uint16_t" --- Position x from the left corner of the window.
	.y      "uint16_t" --- Position y from the top corner of the window.
	.width  "uint16_t" --- Width of view port region.
	.height "uint16_t" --- Height of view port region.

--- Set view rectangle. Draw primitive outside view will be clipped.
func.setViewRect { cname = "set_view_rect_ratio" }
	"void"
	.id    "ViewId"                --- View id.
	.x     "uint16_t"              --- Position x from the left corner of the window.
	.y     "uint16_t"              --- Position y from the top corner of the window.
	.ratio "BackbufferRatio::Enum" --- Width and height will be set in respect to back-buffer size.
	                               --- See: `BackbufferRatio::Enum`.

--- Set view scissor. Draw primitive outside view will be clipped. When
--- _x, _y, _width and _height are set to 0, scissor will be disabled.
func.setViewScissor
	"void"
	.id     "ViewId"   --- View id.
	.x      "uint16_t" --- Position x from the left corner of the window.
	.y      "uint16_t" --- Position y from the top corner of the window.
	.width  "uint16_t" --- Width of view scissor region.
	.height "uint16_t" --- Height of view scissor region.

--- Set view clear flags.
func.setViewClear
	"void"
	.id      "ViewId"   --- View id.
	.flags   "uint16_t" --- Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear
	                    --- operation. See: `BGFX_CLEAR_*`.
	.rgba    "uint32_t" --- Color clear value.
	.depth   "float"    --- Depth clear value.
	.stencil "uint8_t"  --- Stencil clear value.

--- Set view clear flags with different clear color for each
--- frame buffer texture. Must use setClearColor to setup clear color
--- palette.
func.setViewClear { cname = "set_view_clear_mrt" }
	"void"
	.id      "ViewId"   --- View id.
	.flags   "uint16_t" --- Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear
	                    --- operation. See: `BGFX_CLEAR_*`.
	.depth   "float"    --- Depth clear value.
	.stencil "uint8_t"  --- Stencil clear value.
	.c0      "uint8_t"  --- Palette index for frame buffer attachment 0.
	.c1      "uint8_t"  --- Palette index for frame buffer attachment 1.
	.c2      "uint8_t"  --- Palette index for frame buffer attachment 2.
	.c3      "uint8_t"  --- Palette index for frame buffer attachment 3.
	.c4      "uint8_t"  --- Palette index for frame buffer attachment 4.
	.c5      "uint8_t"  --- Palette index for frame buffer attachment 5.
	.c6      "uint8_t"  --- Palette index for frame buffer attachment 6.
	.c7      "uint8_t"  --- Palette index for frame buffer attachment 7.

--- Set view sorting mode.
---
--- @remarks
---   View mode must be set prior calling `bgfx::submit` for the view.
---
func.setViewMode
	"void"
	.id   "ViewId"         --- View id.
	.mode "ViewMode::Enum" --- View sort mode. See `ViewMode::Enum`.

--- Set view frame buffer.
---
--- @remarks
---   Not persistent after `bgfx::reset` call.
---
func.setViewFrameBuffer
	"void"
	.id     "ViewId"            --- View id.
	.handle "FrameBufferHandle" --- Frame buffer handle. Passing `BGFX_INVALID_HANDLE` as
	                            --- frame buffer handle will draw primitives from this view into
	                            --- default back buffer.

--- Set view view and projection matrices, all draw primitives in this
--- view will use these matrices.
func.setViewTransform
	"void"
	.id   "ViewId"      --- View id.
	.view "const void*" --- View matrix.
	.proj "const void*" --- Projection matrix.

--- Post submit view reordering.
func.setViewOrder
	"void"
	.id    "ViewId"        --- First view id.
	.num   "uint16_t"      --- Number of views to remap.
	.order "const ViewId*" --- View remap id table. Passing `NULL` will reset view ids
	                       --- to default state.

--- Begin submitting draw calls from thread.
func.begin { cname = "encoder_begin" }
	"Encoder*"        --- Encoder.
	.forThread "bool" --- Explicitly request an encoder for a worker thread.

--- End submitting draw calls from thread.
func["end"] { cname = "encoder_end" }
	"void"
	.encoder "Encoder*" --- Encoder.

func.Encoder.setMarker
	"void"
	.marker "const char*"

func.Encoder.setState
	"void"
	.state "uint64_t"
	.rgba  "uint32_t"

func.Encoder.setCondition
	"void"
	.handle  "OcclusionQueryHandle"
	.visible "bool"

func.Encoder.setStencil
	"void"
	.fstencil "uint32_t"
	.bstencil "uint32_t"

func.Encoder.setScissor
	"uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.Encoder.setScissor { cname = "set_scissor_cached" }
	"void"
	.cache "uint16_t"

func.Encoder.setTransform
	"uint32_t"
	.mtx "const void*"
	.num "uint16_t"

func.Encoder.setTransform { cname = "set_transform_cached" }
	"void"
	.cache "uint32_t"
	.num   "uint16_t"

func.Encoder.allocTransform
	"uint32_t"
	.transform "Transform*" { out }
	.num       "uint16_t"

func.Encoder.setUniform
	"void"
	.handle "UniformHandle"
	.value  "const void*"
	.num    "uint16_t"

func.Encoder.setIndexBuffer
	"void"
	.handle     "IndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setIndexBuffer { cname = "set_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setIndexBuffer { cname = "set_transient_index_buffer" }
	"void"
	.tib        "const TransientIndexBuffer*"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.Encoder.setVertexBuffer
	"void"
	.stream      "uint8_t"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexBuffer { cname = "set_dynamic_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexBuffer { cname = "set_transient_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.tvb         "const TransientVertexBuffer*"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.Encoder.setVertexCount
	"void"
	.numVertices "uint32_t"

func.Encoder.setInstanceDataBuffer
	"void"
	.idb   "const InstanceDataBuffer*"
	.start "uint32_t"
	.num   "uint32_t"

func.Encoder.setInstanceDataBuffer { cname = "set_instance_data_from_vertex_buffer" }
	"void"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.Encoder.setInstanceDataBuffer { cname = "set_instance_data_from_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.Encoder.setInstanceCount
	"void"
	.numInstances "uint32_t"

func.Encoder.setTexture
	"void"
	.stage   "uint8_t"
	.sampler "UniformHandle"
	.handle  "TextureHandle"
	.flags   "uint32_t"

func.Encoder.touch
	"void"
	.id "ViewId"

func.Encoder.submit
	"void"
	.id            "ViewId"
	.program       "ProgramHandle"
	.depth         "uint32_t"
	.preserveState "bool"

func.Encoder.submit { cname = "submit_occlusion_query" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.occlusionQuery "OcclusionQueryHandle"
	.depth          "uint32_t"
	.preserveState  "bool"

func.Encoder.submit { cname = "submit_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"
	.depth          "uint32_t"
	.preserveState  "bool"

func.Encoder.setBuffer { cname = "set_compute_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "VertexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_dynamic_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicIndexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_dynamic_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicVertexBufferHandle"
	.access "Access::Enum"

func.Encoder.setBuffer { cname = "set_compute_indirect_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndirectBufferHandle"
	.access "Access::Enum"

func.Encoder.setImage
	"void"
	.stage  "uint8_t"
	.handle "TextureHandle"
	.mip    "uint8_t"
	.access "Access::Enum"
	.format "TextureFormat::Enum"  { default = "TextureFormat::Count" }

func.Encoder.dispatch
	"void"
	.id      "ViewId"
	.program "ProgramHandle"
	.numX    "uint32_t"
	.numY    "uint32_t"
	.numZ    "uint32_t"

func.Encoder.dispatch { cname = "dispatch_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"

func.Encoder.discard
	"void"

func.Encoder.blit
	"void"
	.id     "ViewId"
	.dst    "TextureHandle"
	.dstMip "uint8_t"
	.dstX   "uint16_t"
	.dstY   "uint16_t"
	.dstZ   "uint16_t"
	.src    "TextureHandle"
	.srcMip "uint8_t"
	.srcX   "uint16_t"
	.srcY   "uint16_t"
	.srcZ   "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"
	.depth  "uint16_t"

func.requestScreenShot
	"void"
	.handle   "FrameBufferHandle"
	.filePath "const char*"

func.renderFrame
	"RenderFrame::Enum"
	.msecs "int32_t"

func.setPlatformData
	"void"
	.data "const PlatformData &"

func.getInternalData
	"const InternalData*"

func.overrideInternal { cname = "override_internal_texture_ptr" }
	"uintptr_t"
	.handle "TextureHandle"
	.ptr    "uintptr_t"

func.overrideInternal { cname = "override_internal_texture" }
	"uintptr_t"
	.handle  "TextureHandle"
	.width   "uint16_t"
	.height  "uint16_t"
	.numMips "uint8_t"
	.format  "TextureFormat::Enum"
	.flags   "uint32_t"



-- Legacy API:

func.setMarker
	"void"
	.marker "const char*"

func.setState
	"void"
	.state "uint64_t"
	.rgba  "uint32_t"

func.setCondition
	"void"
	.handle  "OcclusionQueryHandle"
	.visible "bool"

func.setStencil
	"void"
	.fstencil "uint32_t"
	.bstencil "uint32_t"

func.setScissor
	"uint16_t"
	.x      "uint16_t"
	.y      "uint16_t"
	.width  "uint16_t"
	.height "uint16_t"

func.setScissor { cname = "set_scissor_cached" }
	"void"
	.cache "uint16_t"

func.setTransform
	"uint32_t"
	.mtx "const void*"
	.num "uint16_t"

func.setTransform { cname = "set_transform_cached" }
	"void"
	.cache "uint32_t"
	.num   "uint16_t"

func.allocTransform
	"uint32_t"
	.transform "Transform*" { out }
	.num       "uint16_t"

func.setUniform
	"void"
	.handle "UniformHandle"
	.value  "const void*"
	.num    "uint16_t"

func.setIndexBuffer
	"void"
	.handle     "IndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setIndexBuffer { cname = "set_dynamic_index_buffer" }
	"void"
	.handle     "DynamicIndexBufferHandle"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setIndexBuffer { cname = "set_transient_index_buffer" }
	"void"
	.tib        "const TransientIndexBuffer*"
	.firstIndex "uint32_t"
	.numIndices "uint32_t"

func.setVertexBuffer
	"void"
	.stream      "uint8_t"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexBuffer { cname = "set_dynamic_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexBuffer { cname = "set_transient_vertex_buffer" }
	"void"
	.stream      "uint8_t"
	.tvb         "const TransientVertexBuffer*"
	.startVertex "uint32_t"
	.numVertices "uint32_t"

func.setVertexCount
	"void"
	.numVertices "uint32_t"

func.setInstanceDataBuffer
	"void"
	.idb   "const InstanceDataBuffer*"
	.start "uint32_t"
	.num   "uint32_t"

func.setInstanceDataBuffer { cname = "set_instance_data_from_vertex_buffer" }
	"void"
	.handle      "VertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.setInstanceDataBuffer { cname = "set_instance_data_from_dynamic_vertex_buffer" }
	"void"
	.handle      "DynamicVertexBufferHandle"
	.startVertex "uint32_t"
	.num         "uint32_t"

func.setInstanceCount
	"void"
	.numInstances "uint32_t"

func.setTexture
	"void"
	.stage   "uint8_t"
	.sampler "UniformHandle"
	.handle  "TextureHandle"
	.flags   "uint32_t"

func.touch
	"void"
	.id "ViewId"

func.submit
	"void"
	.id            "ViewId"
	.program       "ProgramHandle"
	.depth         "uint32_t"
	.preserveState "bool"

func.submit { cname = "submit_occlusion_query" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.occlusionQuery "OcclusionQueryHandle"
	.depth          "uint32_t"
	.preserveState  "bool"

func.submit { cname = "submit_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"
	.depth          "uint32_t"
	.preserveState  "bool"

func.setBuffer { cname = "set_compute_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "VertexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_dynamic_index_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicIndexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_dynamic_vertex_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "DynamicVertexBufferHandle"
	.access "Access::Enum"

func.setBuffer { cname = "set_compute_indirect_buffer" }
	"void"
	.stage  "uint8_t"
	.handle "IndirectBufferHandle"
	.access "Access::Enum"

func.setImage
	"void"
	.stage  "uint8_t"
	.handle "TextureHandle"
	.mip    "uint8_t"
	.access "Access::Enum"
	.format "TextureFormat::Enum"

func.dispatch
	"void"
	.id      "ViewId"
	.program "ProgramHandle"
	.numX    "uint32_t"
	.numY    "uint32_t"
	.numZ    "uint32_t"

func.dispatch { cname = "dispatch_indirect" }
	"void"
	.id             "ViewId"
	.program        "ProgramHandle"
	.indirectHandle "IndirectBufferHandle"
	.start          "uint16_t"
	.num            "uint16_t"

func.discard
	"void"

func.blit
	"void"
	.id     "ViewId"
	.dst    "TextureHandle"
	.dstMip "uint8_t"
	.dstX   "uint16_t"
	.dstY   "uint16_t"
	.dstZ   "uint16_t"
	.src    "TextureHandle"
	.srcMip "uint8_t"      { default = 0 }
	.srcX   "uint16_t"     { default = 0 }
	.srcY   "uint16_t"     { default = 0 }
	.srcZ   "uint16_t"     { default = 0 }
	.width  "uint16_t"     { default = UINT16_MAX }
	.height "uint16_t"     { default = UINT16_MAX }
	.depth  "uint16_t"     { default = UINT16_MAX }
